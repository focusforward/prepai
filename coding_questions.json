[
  {
    "id": "1",
    "title": "Two Sum",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Given array and target, return indices of two numbers that add to target.",
    "examples": [
      {
        "input": "nums=[2,7,11,15], target=9",
        "output": "[0,1]"
      }
    ],
    "constraints": "2<=nums.length<=10^4",
    "hints": [
      "Use hash map to store seen values",
      "For each element check if target-element exists"
    ]
  },
  {
    "id": "2",
    "title": "Best Time to Buy and Sell Stock",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find max profit buying once and selling once from prices array.",
    "examples": [
      {
        "input": "prices=[7,1,5,3,6,4]",
        "output": "5"
      }
    ],
    "constraints": "1<=prices.length<=10^5",
    "hints": [
      "Track minimum price so far",
      "Profit = current - min_so_far"
    ]
  },
  {
    "id": "3",
    "title": "Maximum Subarray",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find contiguous subarray with largest sum.",
    "examples": [
      {
        "input": "nums=[-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "[4,-1,2,1]"
      }
    ],
    "constraints": "-10^4<=nums[i]<=10^4",
    "hints": [
      "Kadane's: running sum, reset to 0 if negative",
      "Track global max"
    ]
  },
  {
    "id": "4",
    "title": "Move Zeroes",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Move all 0s to end in-place preserving order of non-zero elements.",
    "examples": [
      {
        "input": "nums=[0,1,0,3,12]",
        "output": "[1,3,12,0,0]"
      }
    ],
    "constraints": "1<=nums.length<=10^4",
    "hints": [
      "Two pointer approach",
      "One pointer tracks position for next non-zero"
    ]
  },
  {
    "id": "5",
    "title": "Contains Duplicate",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return true if any value appears at least twice.",
    "examples": [
      {
        "input": "nums=[1,2,3,1]",
        "output": "true"
      }
    ],
    "constraints": "1<=nums.length<=10^5",
    "hints": [
      "Use a hash set",
      "Add elements checking if already present"
    ]
  },
  {
    "id": "6",
    "title": "Product of Array Except Self",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return array where answer[i] = product of all elements except nums[i]. No division, O(n).",
    "examples": [
      {
        "input": "nums=[1,2,3,4]",
        "output": "[24,12,8,6]"
      }
    ],
    "constraints": "2<=nums.length<=10^5",
    "hints": [
      "Prefix products left to right",
      "Multiply with suffix products right to left"
    ]
  },
  {
    "id": "7",
    "title": "Find the Duplicate Number",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find duplicate in n+1 integer array with values in [1,n]. No extra space.",
    "examples": [
      {
        "input": "nums=[1,3,4,2,2]",
        "output": "2"
      }
    ],
    "constraints": "1<=n<=10^5",
    "hints": [
      "Floyd's cycle detection on array as linked list",
      "Or binary search on value range"
    ]
  },
  {
    "id": "8",
    "title": "Maximum Product Subarray",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find contiguous subarray with largest product.",
    "examples": [
      {
        "input": "nums=[2,3,-2,4]",
        "output": "6"
      }
    ],
    "constraints": "-10<=nums[i]<=10",
    "hints": [
      "Track both max and min product (negatives flip sign)",
      "Reset when hitting zero"
    ]
  },
  {
    "id": "9",
    "title": "3Sum",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return all unique triplets summing to zero.",
    "examples": [
      {
        "input": "nums=[-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]"
      }
    ],
    "constraints": "0<=nums.length<=3000",
    "hints": [
      "Sort first",
      "Fix one element, two pointers for remaining pair"
    ]
  },
  {
    "id": "10",
    "title": "Container With Most Water",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find two lines forming container with most water.",
    "examples": [
      {
        "input": "height=[1,8,6,2,5,4,8,3,7]",
        "output": "49"
      }
    ],
    "constraints": "2<=n<=10^5",
    "hints": [
      "Two pointers from both ends",
      "Move pointer with smaller height inward"
    ]
  },
  {
    "id": "11",
    "title": "Merge Intervals",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Merge all overlapping intervals.",
    "examples": [
      {
        "input": "[[1,3],[2,6],[8,10]]",
        "output": "[[1,6],[8,10]]"
      }
    ],
    "constraints": "1<=intervals.length<=10^4",
    "hints": [
      "Sort by start time",
      "Merge if current start <= previous end"
    ]
  },
  {
    "id": "12",
    "title": "Search in Rotated Sorted Array",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find target in rotated sorted array in O(log n).",
    "examples": [
      {
        "input": "nums=[4,5,6,7,0,1,2], target=0",
        "output": "4"
      }
    ],
    "constraints": "1<=nums.length<=5000",
    "hints": [
      "Modified binary search",
      "Determine which half is sorted"
    ]
  },
  {
    "id": "13",
    "title": "Subarray Sum Equals K",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Count subarrays whose sum equals k.",
    "examples": [
      {
        "input": "nums=[1,1,1], k=2",
        "output": "2"
      }
    ],
    "constraints": "-1000<=nums[i]<=1000",
    "hints": [
      "Prefix sum + hash map",
      "Check if (sum-k) seen before"
    ]
  },
  {
    "id": "14",
    "title": "Trapping Rain Water",
    "topic": "Array",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Compute water trapped after raining given elevation map.",
    "examples": [
      {
        "input": "height=[0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6"
      }
    ],
    "constraints": "0<=height[i]<=10^5",
    "hints": [
      "Two pointer: water=min(maxL,maxR)-height[i]",
      "Track max from both sides"
    ]
  },
  {
    "id": "15",
    "title": "First Missing Positive",
    "topic": "Array",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Smallest missing positive integer in O(n) time O(1) space.",
    "examples": [
      {
        "input": "nums=[1,2,0]",
        "output": "3"
      }
    ],
    "constraints": "1<=nums.length<=10^5",
    "hints": [
      "Use array as hash map",
      "Place x at index x-1 if 1<=x<=n"
    ]
  },
  {
    "id": "16",
    "title": "Jump Game",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Can you reach the last index given max jump lengths?",
    "examples": [
      {
        "input": "nums=[2,3,1,1,4]",
        "output": "true"
      }
    ],
    "constraints": "1<=nums.length<=10^4",
    "hints": [
      "Track farthest reachable index",
      "Return false if current > farthest"
    ]
  },
  {
    "id": "17",
    "title": "Majority Element",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return element appearing more than n/2 times.",
    "examples": [
      {
        "input": "nums=[3,2,3]",
        "output": "3"
      }
    ],
    "constraints": "1<=n<=5*10^4",
    "hints": [
      "Boyer-Moore Voting Algorithm",
      "Flip candidate when count hits 0"
    ]
  },
  {
    "id": "18",
    "title": "Sort Colors",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Sort array of 0s, 1s, 2s in one pass in-place.",
    "examples": [
      {
        "input": "nums=[2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]"
      }
    ],
    "constraints": "nums[i] is 0, 1, or 2",
    "hints": [
      "Dutch National Flag: three pointers",
      "Swap based on nums[mid] value"
    ]
  },
  {
    "id": "19",
    "title": "Longest Consecutive Sequence",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Length of longest consecutive sequence in O(n).",
    "examples": [
      {
        "input": "nums=[100,4,200,1,3,2]",
        "output": "4"
      }
    ],
    "constraints": "0<=nums.length<=10^5",
    "hints": [
      "Use hash set",
      "Only start counting when num-1 not in set"
    ]
  },
  {
    "id": "20",
    "title": "Kth Largest Element",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find kth largest element in unsorted array.",
    "examples": [
      {
        "input": "nums=[3,2,1,5,6,4], k=2",
        "output": "5"
      }
    ],
    "constraints": "1<=k<=nums.length",
    "hints": [
      "Min-heap of size k",
      "Or QuickSelect for O(n) average"
    ]
  },
  {
    "id": "21",
    "title": "Missing Number",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Find missing number in array of 0 to n.",
    "examples": [
      {
        "input": "nums=[3,0,1]",
        "output": "2"
      }
    ],
    "constraints": "n==nums.length",
    "hints": "Expected sum = n*(n+1)/2, subtract actual sum"
  },
  {
    "id": "22",
    "title": "Next Permutation",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Rearrange into lexicographically next permutation.",
    "examples": [
      {
        "input": "nums=[1,2,3]",
        "output": "[1,3,2]"
      }
    ],
    "constraints": "1<=nums.length<=100",
    "hints": [
      "Find rightmost element smaller than successor",
      "Swap with smallest larger element, reverse suffix"
    ]
  },
  {
    "id": "23",
    "title": "Spiral Matrix",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return all elements of matrix in spiral order.",
    "examples": [
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]"
      }
    ],
    "constraints": "m,n>=1",
    "hints": [
      "Track top/bottom/left/right boundaries",
      "Traverse right,down,left,up, shrink boundaries"
    ]
  },
  {
    "id": "24",
    "title": "Subsets",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return all possible subsets of array of unique elements.",
    "examples": [
      {
        "input": "nums=[1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
      }
    ],
    "constraints": "nums.length<=10",
    "hints": [
      "Backtracking",
      "Or iterative: add each element to all existing subsets"
    ]
  },
  {
    "id": "25",
    "title": "Maximum Sum Circular Subarray",
    "topic": "Array",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Max subarray sum in circular array.",
    "examples": [
      {
        "input": "nums=[5,-3,5]",
        "output": "10"
      }
    ],
    "constraints": "-3*10^4<=nums[i]<=3*10^4",
    "hints": [
      "Case 1: normal max subarray",
      "Case 2: circular = totalSum - minSubarray"
    ]
  },
  {
    "id": "26",
    "title": "Valid Palindrome",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return true if string is palindrome (alphanumeric only, case insensitive).",
    "examples": [
      {
        "input": "s='A man, a plan, a canal: Panama'",
        "output": "true"
      }
    ],
    "constraints": "1<=s.length<=2*10^5",
    "hints": [
      "Two pointers from both ends",
      "Skip non-alphanumeric"
    ]
  },
  {
    "id": "27",
    "title": "Valid Anagram",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return true if t is an anagram of s.",
    "examples": [
      {
        "input": "s='anagram', t='nagaram'",
        "output": "true"
      }
    ],
    "constraints": "1<=length<=5*10^4",
    "hints": [
      "Count character frequencies",
      "Array of size 26"
    ]
  },
  {
    "id": "28",
    "title": "Longest Substring Without Repeating Characters",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find length of longest substring without repeating characters.",
    "examples": [
      {
        "input": "s='abcabcbb'",
        "output": "3"
      }
    ],
    "constraints": "0<=s.length<=5*10^4",
    "hints": [
      "Sliding window with hash set",
      "Expand right, shrink left on duplicate"
    ]
  },
  {
    "id": "29",
    "title": "Longest Palindromic Substring",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return longest palindromic substring.",
    "examples": [
      {
        "input": "s='babad'",
        "output": "bab"
      }
    ],
    "constraints": "1<=s.length<=1000",
    "hints": [
      "Expand around center",
      "Handle odd and even length"
    ]
  },
  {
    "id": "30",
    "title": "Group Anagrams",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Group anagrams from array of strings.",
    "examples": [
      {
        "input": "['eat','tea','tan','ate','nat','bat']",
        "output": "[['eat','tea','ate'],['tan','nat'],['bat']]"
      }
    ],
    "constraints": "1<=strs.length<=10^4",
    "hints": [
      "Sort each string as key",
      "Hash map with sorted string as key"
    ]
  },
  {
    "id": "31",
    "title": "Minimum Window Substring",
    "topic": "String",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum window in s containing all chars of t.",
    "examples": [
      {
        "input": "s='ADOBECODEBANC', t='ABC'",
        "output": "BANC"
      }
    ],
    "constraints": "1<=s.length<=10^5",
    "hints": [
      "Sliding window with two frequency maps",
      "Expand right until valid, shrink left"
    ]
  },
  {
    "id": "32",
    "title": "Valid Parentheses",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return true if brackets are properly opened and closed.",
    "examples": [
      {
        "input": "s='()[]{}'",
        "output": "true"
      }
    ],
    "constraints": "1<=s.length<=10^4",
    "hints": [
      "Use a stack",
      "Push open, pop and match on close"
    ]
  },
  {
    "id": "33",
    "title": "Generate Parentheses",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Generate all combinations of n pairs of valid parentheses.",
    "examples": [
      {
        "input": "n=3",
        "output": "['((()))','(()())','(())()','()(())','()()()']"
      }
    ],
    "constraints": "1<=n<=8",
    "hints": [
      "Backtracking with open/close counts",
      "Add ( if open<n, add ) if close<open"
    ]
  },
  {
    "id": "34",
    "title": "Longest Common Prefix",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find longest common prefix string among array of strings.",
    "examples": [
      {
        "input": "['flower','flow','flight']",
        "output": "fl"
      }
    ],
    "constraints": "1<=strs.length<=200",
    "hints": [
      "Compare first string with each other",
      "Stop at mismatch"
    ]
  },
  {
    "id": "35",
    "title": "Roman to Integer",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Convert Roman numeral to integer.",
    "examples": [
      {
        "input": "s='IX'",
        "output": "9"
      }
    ],
    "constraints": "1<=s.length<=15",
    "hints": [
      "Map symbols to values",
      "If current < next, subtract; else add"
    ]
  },
  {
    "id": "36",
    "title": "Word Break",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Can string s be segmented into dictionary words?",
    "examples": [
      {
        "input": "s='leetcode', wordDict=['leet','code']",
        "output": "true"
      }
    ],
    "constraints": "1<=s.length<=300",
    "hints": [
      "DP: dp[i] = can s[0..i] be segmented",
      "Check all substrings ending at i"
    ]
  },
  {
    "id": "37",
    "title": "Decode String",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Decode string like '3[a2[c]]' to 'accaccacc'.",
    "examples": [
      {
        "input": "s='3[a]2[bc]'",
        "output": "aaabcbc"
      }
    ],
    "constraints": "1<=s.length<=30",
    "hints": [
      "Stack for nested encodings",
      "Push count and string on '[', pop on ']'"
    ]
  },
  {
    "id": "38",
    "title": "Reverse Words in a String",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Reverse the order of words in string.",
    "examples": [
      {
        "input": "s='the sky is blue'",
        "output": "blue is sky the"
      }
    ],
    "constraints": "1<=s.length<=10^4",
    "hints": [
      "Split, filter empty, reverse",
      "Or two-pointer without split"
    ]
  },
  {
    "id": "39",
    "title": "Find All Anagrams",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find all start indices of anagrams of p in s.",
    "examples": [
      {
        "input": "s='cbaebabacd', p='abc'",
        "output": "[0,6]"
      }
    ],
    "constraints": "1<=s.length<=3*10^4",
    "hints": [
      "Sliding window of size p",
      "Compare frequency maps"
    ]
  },
  {
    "id": "40",
    "title": "Longest Repeating Character Replacement",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Longest substring with same char after at most k replacements.",
    "examples": [
      {
        "input": "s='AABABBA', k=1",
        "output": "4"
      }
    ],
    "constraints": "1<=s.length<=10^5",
    "hints": [
      "Sliding window",
      "Valid if length - maxFreq <= k"
    ]
  },
  {
    "id": "41",
    "title": "Implement strStr",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return index of first occurrence of needle in haystack.",
    "examples": [
      {
        "input": "haystack='sadbutsad', needle='sad'",
        "output": "0"
      }
    ],
    "constraints": "1<=lengths<=10^4",
    "hints": [
      "Sliding window of needle length",
      "Or KMP algorithm"
    ]
  },
  {
    "id": "42",
    "title": "Count and Say",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Return nth term of count-and-say sequence.",
    "examples": [
      {
        "input": "n=4",
        "output": "1211"
      }
    ],
    "constraints": "1<=n<=30",
    "hints": [
      "Build each term from previous",
      "Count consecutive characters"
    ]
  },
  {
    "id": "43",
    "title": "Integer to Roman",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Convert integer to Roman numeral.",
    "examples": [
      {
        "input": "num=3749",
        "output": "MMMDCCXLIX"
      }
    ],
    "constraints": "1<=num<=3999",
    "hints": [
      "Greedy with value-symbol pairs",
      "Pick largest symbol that fits"
    ]
  },
  {
    "id": "44",
    "title": "Palindrome Partitioning",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Partition string so every substring is palindrome. Return all partitions.",
    "examples": [
      {
        "input": "s='aab'",
        "output": "[['a','a','b'],['aa','b']]"
      }
    ],
    "constraints": "1<=s.length<=16",
    "hints": [
      "Backtracking trying palindrome prefixes",
      "Precompute palindromes with DP"
    ]
  },
  {
    "id": "45",
    "title": "Text Justification",
    "topic": "String",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Format text so each line has exactly maxWidth characters, fully justified.",
    "examples": [
      {
        "input": "words=['This','is','an','example'], maxWidth=16",
        "output": "['This    is    an','example         ']"
      }
    ],
    "constraints": "1<=words.length<=300",
    "hints": [
      "Greedily pack words into lines",
      "Distribute spaces evenly"
    ]
  },
  {
    "id": "46",
    "title": "Reverse Linked List",
    "topic": "Linked List",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Reverse a singly linked list.",
    "examples": [
      {
        "input": "[1,2,3,4,5]",
        "output": "[5,4,3,2,1]"
      }
    ],
    "constraints": "0<=length<=5000",
    "hints": [
      "Iterative: prev/curr/next pointers",
      "Recursive: reverse rest, point next.next to current"
    ]
  },
  {
    "id": "47",
    "title": "Detect Cycle",
    "topic": "Linked List",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return true if linked list has a cycle.",
    "examples": [
      {
        "input": "[3,2,0,-4] cycle at pos 1",
        "output": "true"
      }
    ],
    "constraints": "0<=nodes<=10^4",
    "hints": [
      "Floyd's tortoise and hare",
      "Slow 1 step, fast 2 steps"
    ]
  },
  {
    "id": "48",
    "title": "Find Middle of Linked List",
    "topic": "Linked List",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Return middle node (second middle if two).",
    "examples": [
      {
        "input": "[1,2,3,4,5]",
        "output": "Node 3"
      }
    ],
    "constraints": "1<=nodes<=100",
    "hints": [
      "Slow and fast pointers",
      "Fast reaches end, slow at middle"
    ]
  },
  {
    "id": "49",
    "title": "Merge Two Sorted Lists",
    "topic": "Linked List",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Merge two sorted linked lists.",
    "examples": [
      {
        "input": "[1,2,4] and [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      }
    ],
    "constraints": "0<=nodes<=50",
    "hints": [
      "Dummy head node",
      "Compare heads, attach smaller"
    ]
  },
  {
    "id": "50",
    "title": "Remove Nth Node From End",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Remove nth node from end in one pass.",
    "examples": [
      {
        "input": "[1,2,3,4,5], n=2",
        "output": "[1,2,3,5]"
      }
    ],
    "constraints": "1<=n<=length",
    "hints": [
      "Two pointers with gap of n",
      "Advance fast n steps first"
    ]
  },
  {
    "id": "51",
    "title": "Linked List Cycle II",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find node where cycle begins.",
    "examples": [
      {
        "input": "[3,2,0,-4], pos=1",
        "output": "Node at index 1"
      }
    ],
    "constraints": "0<=nodes<=10^4",
    "hints": [
      "Floyd's to find meeting point",
      "Move one pointer to head, both advance 1"
    ]
  },
  {
    "id": "52",
    "title": "Add Two Numbers",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Add two numbers represented as reversed linked lists.",
    "examples": [
      {
        "input": "[2,4,3]+[5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342+465=807"
      }
    ],
    "constraints": "1<=nodes<=100",
    "hints": [
      "Traverse simultaneously",
      "Handle carry carefully"
    ]
  },
  {
    "id": "53",
    "title": "LRU Cache",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Design LRU cache with O(1) get and put.",
    "examples": [
      {
        "input": "capacity=2, put(1,1),put(2,2),get(1)=1,put(3,3),get(2)=-1",
        "output": "as described"
      }
    ],
    "constraints": "1<=capacity<=3000",
    "hints": [
      "Doubly linked list + hash map",
      "Move accessed to front, evict from back"
    ]
  },
  {
    "id": "54",
    "title": "Copy List with Random Pointer",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Deep copy linked list with next and random pointers.",
    "examples": [
      {
        "input": "[[7,null],[13,0],[11,4]]",
        "output": "Deep copy"
      }
    ],
    "constraints": "0<=n<=1000",
    "hints": [
      "Hash map original to copy",
      "Or interleave copied nodes"
    ]
  },
  {
    "id": "55",
    "title": "Sort List",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Sort linked list in O(n log n) constant space.",
    "examples": [
      {
        "input": "[4,2,1,3]",
        "output": "[1,2,3,4]"
      }
    ],
    "constraints": "-10^5<=val<=10^5",
    "hints": [
      "Merge sort on linked list",
      "Find middle, split, recurse, merge"
    ]
  },
  {
    "id": "56",
    "title": "Palindrome Linked List",
    "topic": "Linked List",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return true if linked list is palindrome.",
    "examples": [
      {
        "input": "[1,2,2,1]",
        "output": "true"
      }
    ],
    "constraints": "1<=n<=10^5",
    "hints": [
      "Find middle, reverse second half",
      "Compare both halves"
    ]
  },
  {
    "id": "57",
    "title": "Intersection of Two Linked Lists",
    "topic": "Linked List",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find intersection node of two lists.",
    "examples": [
      {
        "input": "[4,1,8,4,5] and [5,6,1,8,4,5]",
        "output": "Node 8"
      }
    ],
    "constraints": "0<=nodes<=3*10^4",
    "hints": [
      "Two pointers switching lists at end",
      "Meet at intersection"
    ]
  },
  {
    "id": "58",
    "title": "Reverse Linked List II",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Reverse nodes from position left to right.",
    "examples": [
      {
        "input": "[1,2,3,4,5], left=2, right=4",
        "output": "[1,4,3,2,5]"
      }
    ],
    "constraints": "1<=left<=right<=n",
    "hints": [
      "Find node before left",
      "Reverse sublist"
    ]
  },
  {
    "id": "59",
    "title": "Reorder List",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Reorder L0->Ln->L1->Ln-1->L2->Ln-2...",
    "examples": [
      {
        "input": "[1,2,3,4]",
        "output": "[1,4,2,3]"
      }
    ],
    "constraints": "1<=n<=5*10^4",
    "hints": [
      "Find middle, reverse second half",
      "Merge alternately"
    ]
  },
  {
    "id": "60",
    "title": "Rotate List",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Rotate linked list right by k places.",
    "examples": [
      {
        "input": "[1,2,3,4,5], k=2",
        "output": "[4,5,1,2,3]"
      }
    ],
    "constraints": "0<=k<=2*10^9",
    "hints": [
      "Make circular, break at (length-k)th node",
      "k = k % length"
    ]
  },
  {
    "id": "61",
    "title": "Maximum Depth of Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return maximum depth of binary tree.",
    "examples": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "output": "3"
      }
    ],
    "constraints": "0<=nodes<=10^4",
    "hints": [
      "1 + max(left depth, right depth)",
      "Or BFS level by level"
    ]
  },
  {
    "id": "62",
    "title": "Validate BST",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Determine if binary tree is a valid BST.",
    "examples": [
      {
        "input": "[2,1,3]",
        "output": "true"
      }
    ],
    "constraints": "1<=nodes<=10^4",
    "hints": [
      "Inorder should be strictly increasing",
      "Or pass min/max bounds recursively"
    ]
  },
  {
    "id": "63",
    "title": "Symmetric Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Check if binary tree is mirror of itself.",
    "examples": [
      {
        "input": "[1,2,2,3,4,4,3]",
        "output": "true"
      }
    ],
    "constraints": "1<=nodes<=1000",
    "hints": [
      "Recursive isMirror(left,right)",
      "Check val equal and subtrees mirror"
    ]
  },
  {
    "id": "64",
    "title": "Level Order Traversal",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return level order traversal as list of lists.",
    "examples": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]"
      }
    ],
    "constraints": "0<=nodes<=2000",
    "hints": [
      "BFS with queue",
      "Track level size"
    ]
  },
  {
    "id": "65",
    "title": "Lowest Common Ancestor BST",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find LCA of two nodes in BST.",
    "examples": [
      {
        "input": "[6,2,8], p=2, q=8",
        "output": "6"
      }
    ],
    "constraints": "2<=nodes<=10^5",
    "hints": [
      "Both < root: go left",
      "Both > root: go right; else root is LCA"
    ]
  },
  {
    "id": "66",
    "title": "Binary Tree Maximum Path Sum",
    "topic": "Tree",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return maximum path sum (path can start and end at any node).",
    "examples": [
      {
        "input": "[-10,9,20,null,null,15,7]",
        "output": "42"
      }
    ],
    "constraints": "-1000<=val<=1000",
    "hints": [
      "For each node: gain = val + max(left,right,0)",
      "Track global max including both branches"
    ]
  },
  {
    "id": "67",
    "title": "Path Sum",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return true if root-to-leaf path sums to targetSum.",
    "examples": [
      {
        "input": "[5,4,8,11,null,13,4], target=22",
        "output": "true"
      }
    ],
    "constraints": "0<=nodes<=5000",
    "hints": [
      "DFS subtracting node value",
      "Return true at leaf if remaining==0"
    ]
  },
  {
    "id": "68",
    "title": "Diameter of Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return length of longest path between any two nodes.",
    "examples": [
      {
        "input": "[1,2,3,4,5]",
        "output": "3"
      }
    ],
    "constraints": "1<=nodes<=10^4",
    "hints": [
      "leftHeight + rightHeight at each node",
      "Track global max during DFS"
    ]
  },
  {
    "id": "69",
    "title": "Balanced Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Check if tree is height-balanced.",
    "examples": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "output": "true"
      }
    ],
    "constraints": "0<=nodes<=5000",
    "hints": [
      "DFS returning height or -1 if unbalanced",
      "Check |leftH - rightH| <= 1"
    ]
  },
  {
    "id": "70",
    "title": "Invert Binary Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Invert binary tree and return root.",
    "examples": [
      {
        "input": "[4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]"
      }
    ],
    "constraints": "0<=nodes<=100",
    "hints": [
      "Swap left and right at every node",
      "Recursive or iterative"
    ]
  },
  {
    "id": "71",
    "title": "Construct Tree from Preorder and Inorder",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Build tree from preorder and inorder traversals.",
    "examples": [
      {
        "input": "preorder=[3,9,20,15,7], inorder=[9,3,15,20,7]",
        "output": "Tree"
      }
    ],
    "constraints": "1<=n<=3000",
    "hints": [
      "First of preorder is root",
      "Find root in inorder to split subtrees"
    ]
  },
  {
    "id": "72",
    "title": "Kth Smallest in BST",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return kth smallest value in BST.",
    "examples": [
      {
        "input": "[3,1,4,null,2], k=1",
        "output": "1"
      }
    ],
    "constraints": "1<=k<=n<=10^4",
    "hints": [
      "Inorder traversal gives sorted order",
      "Stop at kth element"
    ]
  },
  {
    "id": "73",
    "title": "Serialize and Deserialize Binary Tree",
    "topic": "Tree",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Design serialize and deserialize for binary tree.",
    "examples": [
      {
        "input": "[1,2,3,null,null,4,5]",
        "output": "Same tree after roundtrip"
      }
    ],
    "constraints": "0<=nodes<=10^4",
    "hints": [
      "BFS or preorder with null markers",
      "Queue for deserialization"
    ]
  },
  {
    "id": "74",
    "title": "Right Side View",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return values visible from right side (one per level).",
    "examples": [
      {
        "input": "[1,2,3,null,5,null,4]",
        "output": "[1,3,4]"
      }
    ],
    "constraints": "0<=nodes<=100",
    "hints": [
      "BFS: last node of each level",
      "Or DFS: right before left, track depth"
    ]
  },
  {
    "id": "75",
    "title": "Count Good Nodes",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Count nodes where value >= all values on path from root.",
    "examples": [
      {
        "input": "[3,1,4,3,null,1,5]",
        "output": "4"
      }
    ],
    "constraints": "1<=nodes<=10^5",
    "hints": [
      "DFS passing max value on path",
      "Node is good if val >= maxSoFar"
    ]
  },
  {
    "id": "76",
    "title": "All Nodes Distance K",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find all nodes at distance k from target node.",
    "examples": [
      {
        "input": "target=5, k=2",
        "output": "[7,4,1]"
      }
    ],
    "constraints": "1<=k<=1000",
    "hints": [
      "Convert to undirected graph",
      "BFS from target for k steps"
    ]
  },
  {
    "id": "77",
    "title": "Recover BST",
    "topic": "Tree",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Two BST nodes are swapped. Recover without changing structure.",
    "examples": [
      {
        "input": "root=[1,3,null,null,2]",
        "output": "[3,1,null,null,2]"
      }
    ],
    "constraints": "2<=nodes<=1000",
    "hints": [
      "Inorder finds two swapped nodes",
      "First wrong: prev>curr; Second: prev>curr again"
    ]
  },
  {
    "id": "78",
    "title": "Unique BSTs",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return number of structurally unique BSTs with n nodes.",
    "examples": [
      {
        "input": "n=3",
        "output": "5"
      }
    ],
    "constraints": "1<=n<=19",
    "hints": [
      "Catalan number",
      "dp[n] = sum of dp[i-1]*dp[n-i] for i in 1..n"
    ]
  },
  {
    "id": "79",
    "title": "Convert Sorted Array to BST",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Convert sorted array to height-balanced BST.",
    "examples": [
      {
        "input": "[-10,-3,0,5,9]",
        "output": "[0,-3,9,-10,null,5]"
      }
    ],
    "constraints": "1<=nums.length<=10^4",
    "hints": [
      "Pick middle as root",
      "Recurse on left and right halves"
    ]
  },
  {
    "id": "80",
    "title": "Flatten Tree to Linked List",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Flatten binary tree to linked list in-place using preorder.",
    "examples": [
      {
        "input": "[1,2,5,3,4,null,6]",
        "output": "[1,null,2,null,3,null,4,null,5,null,6]"
      }
    ],
    "constraints": "0<=nodes<=2000",
    "hints": [
      "Reverse postorder: right, left, root",
      "Morris traversal"
    ]
  },
  {
    "id": "81",
    "title": "Climbing Stairs",
    "topic": "Dynamic Programming",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Count distinct ways to climb n steps (1 or 2 at a time).",
    "examples": [
      {
        "input": "n=3",
        "output": "3"
      }
    ],
    "constraints": "1<=n<=45",
    "hints": [
      "dp[i]=dp[i-1]+dp[i-2]",
      "It's Fibonacci"
    ]
  },
  {
    "id": "82",
    "title": "House Robber",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Max money robbing houses, no two adjacent.",
    "examples": [
      {
        "input": "[2,7,9,3,1]",
        "output": "12"
      }
    ],
    "constraints": "1<=nums.length<=100",
    "hints": [
      "dp[i]=max(dp[i-1], dp[i-2]+nums[i])",
      "Only need previous two values"
    ]
  },
  {
    "id": "83",
    "title": "Coin Change",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Fewest coins to make amount. Return -1 if impossible.",
    "examples": [
      {
        "input": "coins=[1,5,11], amount=15",
        "output": "3"
      }
    ],
    "constraints": "1<=coins.length<=12",
    "hints": [
      "dp[i]=min coins to make i",
      "For each coin: dp[i]=min(dp[i], dp[i-coin]+1)"
    ]
  },
  {
    "id": "84",
    "title": "Longest Increasing Subsequence",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return length of longest strictly increasing subsequence.",
    "examples": [
      {
        "input": "[10,9,2,5,3,7,101,18]",
        "output": "4"
      }
    ],
    "constraints": "1<=nums.length<=2500",
    "hints": [
      "dp[i] = LIS ending at i",
      "O(n log n): patience sorting with binary search"
    ]
  },
  {
    "id": "85",
    "title": "Knapsack 0/1",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Max value fitting in knapsack of capacity W.",
    "examples": [
      {
        "input": "weights=[1,3,4,5], values=[1,4,5,7], W=7",
        "output": "9"
      }
    ],
    "constraints": "1<=n,W<=1000",
    "hints": [
      "dp[i][w] = max value using first i items with capacity w",
      "Include or exclude item i"
    ]
  },
  {
    "id": "86",
    "title": "Longest Common Subsequence",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Length of LCS of two strings.",
    "examples": [
      {
        "input": "text1='abcde', text2='ace'",
        "output": "3"
      }
    ],
    "constraints": "1<=lengths<=1000",
    "hints": [
      "dp[i][j] = LCS of text1[0..i] and text2[0..j]",
      "If chars match: dp[i][j]=dp[i-1][j-1]+1"
    ]
  },
  {
    "id": "87",
    "title": "Edit Distance",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum operations to convert word1 to word2.",
    "examples": [
      {
        "input": "word1='horse', word2='ros'",
        "output": "3"
      }
    ],
    "constraints": "0<=lengths<=500",
    "hints": [
      "dp[i][j] = edit distance of prefixes",
      "Handle insert, delete, replace"
    ]
  },
  {
    "id": "88",
    "title": "Unique Paths",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "How many unique paths from top-left to bottom-right of m x n grid?",
    "examples": [
      {
        "input": "m=3, n=7",
        "output": "28"
      }
    ],
    "constraints": "1<=m,n<=100",
    "hints": [
      "dp[i][j]=dp[i-1][j]+dp[i][j-1]",
      "Or C(m+n-2,m-1)"
    ]
  },
  {
    "id": "89",
    "title": "Minimum Path Sum",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Min path sum top-left to bottom-right.",
    "examples": [
      {
        "input": "[[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7"
      }
    ],
    "constraints": "1<=m,n<=200",
    "hints": [
      "dp[i][j]=grid[i][j]+min(dp[i-1][j],dp[i][j-1])",
      "Can modify grid in-place"
    ]
  },
  {
    "id": "90",
    "title": "Decode Ways",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Count ways to decode digit string (A=1...Z=26).",
    "examples": [
      {
        "input": "s='226'",
        "output": "3"
      }
    ],
    "constraints": "1<=s.length<=100",
    "hints": [
      "dp[i]=ways to decode s[0..i]",
      "Check single and two-digit combos"
    ]
  },
  {
    "id": "91",
    "title": "Partition Equal Subset Sum",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Can array be partitioned into two equal-sum subsets?",
    "examples": [
      {
        "input": "[1,5,11,5]",
        "output": "true"
      }
    ],
    "constraints": "1<=nums.length<=200",
    "hints": [
      "0/1 knapsack: can we reach sum/2?",
      "dp[s]=true if sum s achievable"
    ]
  },
  {
    "id": "92",
    "title": "Palindromic Substrings",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Count palindromic substrings in string.",
    "examples": [
      {
        "input": "s='abc'",
        "output": "3"
      }
    ],
    "constraints": "1<=s.length<=1000",
    "hints": [
      "Expand around each center",
      "Or DP: dp[i][j]=palindrome?"
    ]
  },
  {
    "id": "93",
    "title": "Maximum Square",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Largest square of 1s in binary matrix. Return area.",
    "examples": [
      {
        "input": "matrix with 1s and 0s",
        "output": "4"
      }
    ],
    "constraints": "m,n>=1",
    "hints": [
      "dp[i][j]=side of max square ending at (i,j)",
      "dp[i][j]=min(left,up,diag)+1"
    ]
  },
  {
    "id": "94",
    "title": "Word Break II",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return all sentence segmentations using dictionary words.",
    "examples": [
      {
        "input": "s='catsanddog', wordDict=['cat','cats','and','sand','dog']",
        "output": "['cats and dog','cat sand dog']"
      }
    ],
    "constraints": "1<=s.length<=20",
    "hints": [
      "DFS with memoization",
      "dp[i]=sentences for s[i:]"
    ]
  },
  {
    "id": "95",
    "title": "Burst Balloons",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Burst balloons to maximize coins. Bursting i gives nums[i-1]*nums[i]*nums[i+1].",
    "examples": [
      {
        "input": "nums=[3,1,5,8]",
        "output": "167"
      }
    ],
    "constraints": "1<=nums.length<=300",
    "hints": [
      "Interval DP: last balloon to burst in range",
      "dp[i][j]=max coins bursting all between i and j"
    ]
  },
  {
    "id": "96",
    "title": "Triangle Min Path Sum",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Min path sum from top to bottom of triangle.",
    "examples": [
      {
        "input": "[[2],[3,4],[6,5,7],[4,1,8,3]]",
        "output": "11"
      }
    ],
    "constraints": "1<=triangle.length<=200",
    "hints": [
      "Bottom-up DP",
      "dp[j]=triangle[i][j]+min(dp[j],dp[j+1])"
    ]
  },
  {
    "id": "97",
    "title": "Regular Expression Matching",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Implement regex with . and *.",
    "examples": [
      {
        "input": "s='aa', p='a*'",
        "output": "true"
      }
    ],
    "constraints": "1<=lengths<=30",
    "hints": [
      "dp[i][j]=s[0..i] matches p[0..j]",
      "Handle * as zero or more of preceding"
    ]
  },
  {
    "id": "98",
    "title": "Ugly Number II",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return nth ugly number (only factors 2,3,5).",
    "examples": [
      {
        "input": "n=10",
        "output": "12"
      }
    ],
    "constraints": "1<=n<=1690",
    "hints": [
      "Three pointers for multiples of 2,3,5",
      "Pick minimum, advance that pointer"
    ]
  },
  {
    "id": "99",
    "title": "Perfect Squares",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Least number of perfect squares summing to n.",
    "examples": [
      {
        "input": "n=12",
        "output": "3",
        "explanation": "4+4+4"
      }
    ],
    "constraints": "1<=n<=10^4",
    "hints": [
      "dp[i]=min squares summing to i",
      "For each j^2<=i: dp[i]=min(dp[i],dp[i-j^2]+1)"
    ]
  },
  {
    "id": "100",
    "title": "House Robber II",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Houses in circle. Max money with no adjacent robberies.",
    "examples": [
      {
        "input": "nums=[2,3,2]",
        "output": "3"
      }
    ],
    "constraints": "1<=nums.length<=100",
    "hints": [
      "Run House Robber on nums[0..n-2] and nums[1..n-1]",
      "Take maximum"
    ]
  },
  {
    "id": "101",
    "title": "Counting Bits",
    "topic": "Dynamic Programming",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Return array where ans[i] = number of 1s in binary of i.",
    "examples": [
      {
        "input": "n=5",
        "output": "[0,1,1,2,1,2]"
      }
    ],
    "constraints": "0<=n<=10^5",
    "hints": [
      "dp[i]=dp[i>>1]+(i&1)",
      "Use right shift and last bit"
    ]
  },
  {
    "id": "102",
    "title": "Minimum Cost Climbing Stairs",
    "topic": "Dynamic Programming",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Find min cost to reach top of staircase.",
    "examples": [
      {
        "input": "cost=[10,15,20]",
        "output": "15"
      }
    ],
    "constraints": "2<=cost.length<=1000",
    "hints": [
      "dp[i]=cost[i]+min(dp[i-1],dp[i-2])",
      "Start from index 0 or 1"
    ]
  },
  {
    "id": "103",
    "title": "Longest Bitonic Subsequence",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Length of longest subsequence that first increases then decreases.",
    "examples": [
      {
        "input": "arr=[1,11,2,10,4,5,2,1]",
        "output": "6"
      }
    ],
    "constraints": "1<=arr.length<=1000",
    "hints": [
      "LIS from left + LDS from right at each index",
      "Combine: lis[i]+lds[i]-1"
    ]
  },
  {
    "id": "104",
    "title": "Number of LIS",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return number of longest increasing subsequences.",
    "examples": [
      {
        "input": "nums=[1,3,5,4,7]",
        "output": "2"
      }
    ],
    "constraints": "1<=nums.length<=2000",
    "hints": [
      "Track length and count of LIS at each position",
      "dp_len[i] and dp_cnt[i]"
    ]
  },
  {
    "id": "105",
    "title": "Frog Jump",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Frog can jump k-1,k,k+1 from stone to stone. Can it reach last stone?",
    "examples": [
      {
        "input": "stones=[0,1,3,5,6,8,12,17]",
        "output": "true"
      }
    ],
    "constraints": "2<=stones.length<=2000",
    "hints": [
      "DP with set of jumps at each stone",
      "BFS/DFS with memoization"
    ]
  },
  {
    "id": "106",
    "title": "Number of Islands",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Count islands (connected 1s) in binary grid.",
    "examples": [
      {
        "input": "grid of 1s and 0s",
        "output": "2"
      }
    ],
    "constraints": "1<=m,n<=300",
    "hints": [
      "DFS/BFS from each unvisited 1",
      "Mark visited to avoid recount"
    ]
  },
  {
    "id": "107",
    "title": "Clone Graph",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Deep copy of undirected graph.",
    "examples": [
      {
        "input": "adjList=[[2,4],[1,3],[2,4],[1,3]]",
        "output": "Deep copy"
      }
    ],
    "constraints": "1<=nodes<=100",
    "hints": [
      "BFS with hash map original->clone",
      "Clone neighbors recursively"
    ]
  },
  {
    "id": "108",
    "title": "Course Schedule",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Can you finish all courses given prerequisites?",
    "examples": [
      {
        "input": "numCourses=2, [[1,0]]",
        "output": "true"
      }
    ],
    "constraints": "1<=numCourses<=2000",
    "hints": [
      "Detect cycle in directed graph",
      "Topological sort or DFS coloring"
    ]
  },
  {
    "id": "109",
    "title": "Course Schedule II",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return valid course ordering.",
    "examples": [
      {
        "input": "numCourses=4, [[1,0],[2,0],[3,1],[3,2]]",
        "output": "[0,1,2,3]"
      }
    ],
    "constraints": "1<=numCourses<=2000",
    "hints": [
      "Topological sort",
      "DFS: add to result after visiting neighbors"
    ]
  },
  {
    "id": "110",
    "title": "Pacific Atlantic Water Flow",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find cells from which water can flow to both oceans.",
    "examples": [
      {
        "input": "heights grid",
        "output": "list of cells"
      }
    ],
    "constraints": "1<=m,n<=200",
    "hints": [
      "Reverse flow BFS from both ocean borders",
      "Find intersection"
    ]
  },
  {
    "id": "111",
    "title": "Word Ladder",
    "topic": "Graph",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Min steps to transform beginWord to endWord changing one letter at a time.",
    "examples": [
      {
        "input": "beginWord=hit, endWord=cog, wordList=[hot,dot,dog,lot,log,cog]",
        "output": "5"
      }
    ],
    "constraints": "1<=word.length<=10",
    "hints": [
      "BFS from beginWord",
      "Try all 26 letter substitutions"
    ]
  },
  {
    "id": "112",
    "title": "Number of Connected Components",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Count connected components in undirected graph.",
    "examples": [
      {
        "input": "n=5, edges=[[0,1],[1,2],[3,4]]",
        "output": "2"
      }
    ],
    "constraints": "1<=n<=2000",
    "hints": [
      "Union-Find or DFS/BFS",
      "Count distinct roots or DFS calls"
    ]
  },
  {
    "id": "113",
    "title": "Graph Valid Tree",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Determine if n nodes and edges form a valid tree.",
    "examples": [
      {
        "input": "n=5, edges=[[0,1],[0,2],[0,3],[1,4]]",
        "output": "true"
      }
    ],
    "constraints": "1<=n<=2000",
    "hints": [
      "Valid tree: connected + no cycle",
      "edges.length==n-1 and connected"
    ]
  },
  {
    "id": "114",
    "title": "Topological Sort",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return vertices of DAG in topological order.",
    "examples": [
      {
        "input": "n=6, edges=[[5,2],[5,0],[4,0],[4,1],[2,3],[3,1]]",
        "output": "[5,4,2,3,1,0]"
      }
    ],
    "constraints": "1<=n<=10^4",
    "hints": [
      "Kahn's: start with zero in-degree nodes",
      "DFS: add after visiting all neighbors"
    ]
  },
  {
    "id": "115",
    "title": "Rotting Oranges",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minutes until no fresh oranges, or -1 if impossible.",
    "examples": [
      {
        "input": "[[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4"
      }
    ],
    "constraints": "m,n>=1",
    "hints": [
      "Multi-source BFS from all rotten oranges",
      "Track time and fresh count"
    ]
  },
  {
    "id": "116",
    "title": "01 Matrix",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Distance to nearest 0 for each cell.",
    "examples": [
      {
        "input": "[[0,0,0],[0,1,0],[0,0,0]]",
        "output": "[[0,0,0],[0,1,0],[0,0,0]]"
      }
    ],
    "constraints": "1<=m,n<=10^4",
    "hints": [
      "Multi-source BFS from all 0 cells",
      "Or DP two passes"
    ]
  },
  {
    "id": "117",
    "title": "Shortest Path Dijkstra",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find shortest path from source to all vertices.",
    "examples": [
      {
        "input": "weighted graph, source=0",
        "output": "distances from 0"
      }
    ],
    "constraints": "1<=n<=10^4",
    "hints": [
      "Min-heap with distances",
      "Relax edges greedily"
    ]
  },
  {
    "id": "118",
    "title": "Minimum Spanning Tree",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find MST weight using Kruskal's algorithm.",
    "examples": [
      {
        "input": "n=4, edges with weights",
        "output": "MST weight"
      }
    ],
    "constraints": "1<=n<=1000",
    "hints": [
      "Sort edges by weight",
      "Add if no cycle (Union-Find)"
    ]
  },
  {
    "id": "119",
    "title": "Redundant Connection",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find edge to remove to restore tree property.",
    "examples": [
      {
        "input": "edges=[[1,2],[1,3],[2,3]]",
        "output": "[2,3]"
      }
    ],
    "constraints": "3<=n<=1000",
    "hints": [
      "Union-Find: add edges one by one",
      "Return first edge whose nodes already connected"
    ]
  },
  {
    "id": "120",
    "title": "Network Delay Time",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Time for signal to reach all nodes from k.",
    "examples": [
      {
        "input": "times=[[2,1,1],[2,3,1],[3,4,1]], n=4, k=2",
        "output": "2"
      }
    ],
    "constraints": "1<=k<=n<=100",
    "hints": [
      "Dijkstra from node k",
      "Return max distance"
    ]
  },
  {
    "id": "121",
    "title": "Is Graph Bipartite",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Can graph be 2-colored with no adjacent same color?",
    "examples": [
      {
        "input": "graph=[[1,2,3],[0,2],[0,1,3],[0,2]]",
        "output": "false"
      }
    ],
    "constraints": "1<=graph.length<=100",
    "hints": [
      "BFS/DFS with 2-coloring",
      "Conflict means not bipartite"
    ]
  },
  {
    "id": "122",
    "title": "Critical Connections",
    "topic": "Graph",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find all bridges whose removal disconnects the network.",
    "examples": [
      {
        "input": "n=4, connections=[[0,1],[1,2],[2,0],[1,3]]",
        "output": "[[1,3]]"
      }
    ],
    "constraints": "2<=n<=10^5",
    "hints": [
      "Tarjan's bridge algorithm",
      "Track discovery time and low values"
    ]
  },
  {
    "id": "123",
    "title": "Alien Dictionary",
    "topic": "Graph",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Determine character order from sorted alien word list.",
    "examples": [
      {
        "input": "words=['wrt','wrf','er','ett','rftt']",
        "output": "wertf"
      }
    ],
    "constraints": "1<=words.length<=100",
    "hints": [
      "Build directed graph from adjacent words",
      "Topological sort"
    ]
  },
  {
    "id": "124",
    "title": "Surrounded Regions",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Capture all O regions surrounded by X.",
    "examples": [
      {
        "input": "board of X and O",
        "output": "O regions captured"
      }
    ],
    "constraints": "m,n>=1",
    "hints": [
      "DFS from border O's mark safe",
      "Flip all unsafe O to X"
    ]
  },
  {
    "id": "125",
    "title": "Swim in Rising Water",
    "topic": "Graph",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum time to swim from (0,0) to (n-1,n-1).",
    "examples": [
      {
        "input": "grid=[[0,2],[1,3]]",
        "output": "3"
      }
    ],
    "constraints": "1<=n<=50",
    "hints": [
      "Modified Dijkstra: cost=max elevation on path",
      "Or binary search + BFS"
    ]
  },
  {
    "id": "126",
    "title": "Merge Sort",
    "topic": "Sorting",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Implement merge sort to sort array in ascending order.",
    "examples": [
      {
        "input": "[64,34,25,12,22,11,90]",
        "output": "[11,12,22,25,34,64,90]"
      }
    ],
    "constraints": "1<=arr.length<=10^5",
    "hints": [
      "Divide into halves recursively",
      "Merge two sorted halves"
    ]
  },
  {
    "id": "127",
    "title": "Quick Sort",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Implement quicksort to sort array in-place.",
    "examples": [
      {
        "input": "[10,7,8,9,1,5]",
        "output": "[1,5,7,8,9,10]"
      }
    ],
    "constraints": "1<=arr.length<=10^5",
    "hints": [
      "Pick pivot, partition around it",
      "Recurse on both halves"
    ]
  },
  {
    "id": "128",
    "title": "Top K Frequent Elements",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return k most frequent elements.",
    "examples": [
      {
        "input": "nums=[1,1,1,2,2,3], k=2",
        "output": "[1,2]"
      }
    ],
    "constraints": "1<=k<=unique elements",
    "hints": [
      "Count frequencies",
      "Bucket sort or min-heap"
    ]
  },
  {
    "id": "129",
    "title": "Largest Number",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Arrange integers to form largest number.",
    "examples": [
      {
        "input": "[3,30,34,5,9]",
        "output": "9534330"
      }
    ],
    "constraints": "1<=nums.length<=100",
    "hints": [
      "Custom comparator: compare ab vs ba",
      "Sort with this comparator"
    ]
  },
  {
    "id": "130",
    "title": "Meeting Rooms II",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum conference rooms required for all meetings.",
    "examples": [
      {
        "input": "[[0,30],[5,10],[15,20]]",
        "output": "2"
      }
    ],
    "constraints": "0<=intervals.length<=10^4",
    "hints": [
      "Sort by start time",
      "Min-heap of end times"
    ]
  },
  {
    "id": "131",
    "title": "Find Median from Data Stream",
    "topic": "Sorting",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Median of dynamically inserted integers.",
    "examples": [
      {
        "input": "add(1),add(2),findMedian=1.5,add(3),findMedian=2.0",
        "output": "as described"
      }
    ],
    "constraints": "1<=val<=10^5",
    "hints": [
      "Max-heap lower half, min-heap upper half",
      "Balance heap sizes"
    ]
  },
  {
    "id": "132",
    "title": "Heap Sort",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Implement heap sort using max-heap.",
    "examples": [
      {
        "input": "[12,11,13,5,6,7]",
        "output": "[5,6,7,11,12,13]"
      }
    ],
    "constraints": "1<=arr.length<=10^5",
    "hints": [
      "Build max-heap",
      "Extract max repeatedly"
    ]
  },
  {
    "id": "133",
    "title": "Sort Characters by Frequency",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Sort string characters by decreasing frequency.",
    "examples": [
      {
        "input": "s='tree'",
        "output": "eert"
      }
    ],
    "constraints": "1<=s.length<=5*10^5",
    "hints": [
      "Count frequencies",
      "Sort by frequency descending"
    ]
  },
  {
    "id": "134",
    "title": "Minimum Arrows to Burst Balloons",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Minimum arrows to burst all balloon intervals.",
    "examples": [
      {
        "input": "[[10,16],[2,8],[1,6],[7,12]]",
        "output": "2"
      }
    ],
    "constraints": "1<=points.length<=10^5",
    "hints": [
      "Sort by end coordinate",
      "Greedily shoot at end of each group"
    ]
  },
  {
    "id": "135",
    "title": "H-Index",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Max h where researcher has h papers with at least h citations.",
    "examples": [
      {
        "input": "citations=[3,0,6,1,5]",
        "output": "3"
      }
    ],
    "constraints": "1<=citations.length<=5000",
    "hints": [
      "Sort descending",
      "Find largest i where citations[i]>=i+1"
    ]
  },
  {
    "id": "136",
    "title": "Binary Search",
    "topic": "Searching",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find target in sorted array using binary search.",
    "examples": [
      {
        "input": "nums=[-1,0,3,5,9,12], target=9",
        "output": "4"
      }
    ],
    "constraints": "1<=nums.length<=10^4",
    "hints": [
      "left and right pointers",
      "mid=(left+right)//2"
    ]
  },
  {
    "id": "137",
    "title": "Search a 2D Matrix",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Search target in sorted m x n matrix in O(log mn).",
    "examples": [
      {
        "input": "matrix=[[1,3,5,7],[10,11,16,20]], target=3",
        "output": "true"
      }
    ],
    "constraints": "1<=m,n<=100",
    "hints": [
      "Treat as flattened sorted array",
      "Or start top-right: left if big, down if small"
    ]
  },
  {
    "id": "138",
    "title": "Find Peak Element",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find a peak element in O(log n).",
    "examples": [
      {
        "input": "[1,2,3,1]",
        "output": "2"
      }
    ],
    "constraints": "1<=nums.length<=500",
    "hints": [
      "If nums[mid]<nums[mid+1] peak is right",
      "Else peak is left or at mid"
    ]
  },
  {
    "id": "139",
    "title": "Sqrt(x)",
    "topic": "Searching",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Integer square root rounded down.",
    "examples": [
      {
        "input": "x=8",
        "output": "2"
      }
    ],
    "constraints": "0<=x<=2^31-1",
    "hints": [
      "Binary search between 0 and x//2+1",
      "Check mid*mid<=x<(mid+1)*(mid+1)"
    ]
  },
  {
    "id": "140",
    "title": "Kth Smallest in Sorted Matrix",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find kth smallest in n x n sorted matrix.",
    "examples": [
      {
        "input": "[[1,5,9],[10,11,13],[12,13,15]], k=8",
        "output": "13"
      }
    ],
    "constraints": "n>=1",
    "hints": [
      "Binary search on value range",
      "Count elements<=mid"
    ]
  },
  {
    "id": "141",
    "title": "Capacity to Ship Packages",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Minimum ship capacity to ship all packages in D days.",
    "examples": [
      {
        "input": "weights=[1,2,3,4,5,6,7,8,9,10], days=5",
        "output": "15"
      }
    ],
    "constraints": "1<=days<=weights.length",
    "hints": [
      "Binary search between max(weights) and sum",
      "Verify given capacity fits in D days"
    ]
  },
  {
    "id": "142",
    "title": "Find First and Last Position",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find start and end index of target in sorted array.",
    "examples": [
      {
        "input": "nums=[5,7,7,8,8,10], target=8",
        "output": "[3,4]"
      }
    ],
    "constraints": "0<=nums.length<=10^5",
    "hints": [
      "Two binary searches: leftmost and rightmost",
      "Use lo/hi bias in mid calculation"
    ]
  },
  {
    "id": "143",
    "title": "Median of Two Sorted Arrays",
    "topic": "Searching",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Median of two sorted arrays in O(log(m+n)).",
    "examples": [
      {
        "input": "nums1=[1,3], nums2=[2]",
        "output": "2.0"
      }
    ],
    "constraints": "m+n>=1",
    "hints": [
      "Binary search on smaller array",
      "Partition both arrays"
    ]
  },
  {
    "id": "144",
    "title": "Single Element in Sorted Array",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find element appearing once in sorted array of doubles.",
    "examples": [
      {
        "input": "[1,1,2,3,3,4,4,8,8]",
        "output": "2"
      }
    ],
    "constraints": "1<=nums.length<=10^5",
    "hints": [
      "Binary search on even indices",
      "Compare with neighbor to decide direction"
    ]
  },
  {
    "id": "145",
    "title": "Split Array Largest Sum",
    "topic": "Searching",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Split array into m subarrays minimizing the largest sum.",
    "examples": [
      {
        "input": "nums=[7,2,5,10,8], m=2",
        "output": "18"
      }
    ],
    "constraints": "1<=m<=nums.length",
    "hints": [
      "Binary search on answer",
      "Check if max sum allows m subarrays"
    ]
  },
  {
    "id": "146",
    "title": "Aggressive Cows",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Place C cows to maximize minimum distance.",
    "examples": [
      {
        "input": "stalls=[1,2,4,8,9], C=3",
        "output": "3"
      }
    ],
    "constraints": "2<=N<=10^5",
    "hints": [
      "Binary search on minimum distance",
      "Check if distance allows all cows"
    ]
  },
  {
    "id": "147",
    "title": "Minimum in Rotated Sorted Array",
    "topic": "Searching",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find minimum in rotated sorted array in O(log n).",
    "examples": [
      {
        "input": "[3,4,5,1,2]",
        "output": "1"
      }
    ],
    "constraints": "1<=nums.length<=5000",
    "hints": [
      "If mid>right, minimum is in right half",
      "Binary search"
    ]
  },
  {
    "id": "148",
    "title": "Two Sum Hash Map",
    "topic": "Hash",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Find two indices summing to target using O(n) hash map approach.",
    "examples": [
      {
        "input": "nums=[2,7,11,15], target=9",
        "output": "[0,1]"
      }
    ],
    "constraints": "2<=nums.length<=10^4",
    "hints": [
      "Store num:index in map",
      "Check target-num exists"
    ]
  },
  {
    "id": "149",
    "title": "Top K Frequent Elements",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return k most frequent elements using hash map.",
    "examples": [
      {
        "input": "nums=[1,1,1,2,2,3], k=2",
        "output": "[1,2]"
      }
    ],
    "constraints": "1<=k<=unique",
    "hints": [
      "Count with hash map",
      "Bucket sort or heap for top k"
    ]
  },
  {
    "id": "150",
    "title": "Subarray Sum Equals K",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Count subarrays summing to k using prefix sums.",
    "examples": [
      {
        "input": "nums=[1,1,1], k=2",
        "output": "2"
      }
    ],
    "constraints": "-1000<=nums[i]<=1000",
    "hints": [
      "Prefix sum + hash map",
      "Check if (sum-k) seen before"
    ]
  },
  {
    "id": "151",
    "title": "Longest Subarray Sum K",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Longest subarray summing to k.",
    "examples": [
      {
        "input": "nums=[10,5,2,7,1,9], k=15",
        "output": "4"
      }
    ],
    "constraints": "1<=nums.length<=10^5",
    "hints": [
      "Prefix sum + first occurrence map",
      "length = index - first_occurrence[sum-k]"
    ]
  },
  {
    "id": "152",
    "title": "Contiguous Array",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Longest subarray with equal 0s and 1s.",
    "examples": [
      {
        "input": "[0,1,0]",
        "output": "2"
      }
    ],
    "constraints": "1<=nums.length<=10^5",
    "hints": [
      "Replace 0 with -1",
      "Longest subarray summing to 0"
    ]
  },
  {
    "id": "153",
    "title": "Happy Number",
    "topic": "Hash",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Is n a happy number? Replace by sum of squared digits until 1 or cycle.",
    "examples": [
      {
        "input": "n=19",
        "output": "true"
      }
    ],
    "constraints": "1<=n<=2^31-1",
    "hints": [
      "Hash set to detect cycle",
      "Or Floyd's fast/slow"
    ]
  },
  {
    "id": "154",
    "title": "4Sum II",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Count tuples where A[i]+B[j]+C[k]+D[l]==0.",
    "examples": [
      {
        "input": "A=[1,2],B=[-2,-1],C=[-1,2],D=[0,2]",
        "output": "2"
      }
    ],
    "constraints": "1<=length<=200",
    "hints": [
      "Hash map of A[i]+B[j] sums",
      "For C[k]+D[l] check negation in map"
    ]
  },
  {
    "id": "155",
    "title": "Design HashMap",
    "topic": "Hash",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Implement HashMap without built-in libraries.",
    "examples": [
      {
        "input": "put(1,1),put(2,2),get(1)=1,get(3)=-1",
        "output": "as described"
      }
    ],
    "constraints": "0<=key,value<=10^6",
    "hints": [
      "Array of buckets with chaining",
      "Hash = key % bucketSize"
    ]
  },
  {
    "id": "156",
    "title": "Brick Wall",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Line crossing fewest bricks.",
    "examples": [
      {
        "input": "wall rows",
        "output": "2"
      }
    ],
    "constraints": "1<=wall.length<=10^4",
    "hints": [
      "Count gap positions with hash map",
      "Answer = rows - max gaps"
    ]
  },
  {
    "id": "157",
    "title": "LFU Cache",
    "topic": "Hash",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Least Frequently Used cache with O(1) get and put.",
    "examples": [
      {
        "input": "LFUCache(2): put(1,1),put(2,2),get(1)=1,put(3,3),get(2)=-1",
        "output": "as described"
      }
    ],
    "constraints": "1<=capacity<=10^4",
    "hints": [
      "HashMap key->val, key->freq, freq->LinkedHashSet",
      "Track minimum frequency"
    ]
  },
  {
    "id": "158",
    "title": "Activity Selection",
    "topic": "Greedy",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Maximum non-overlapping activities.",
    "examples": [
      {
        "input": "start=[1,3,0,5,8,5], end=[2,4,6,7,9,9]",
        "output": "4"
      }
    ],
    "constraints": "1<=n<=10^5",
    "hints": [
      "Sort by end time",
      "Always pick earliest ending"
    ]
  },
  {
    "id": "159",
    "title": "Fractional Knapsack",
    "topic": "Greedy",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Maximize value with fractional items.",
    "examples": [
      {
        "input": "weights=[10,20,30], values=[60,100,120], W=50",
        "output": "240"
      }
    ],
    "constraints": "1<=n<=1000",
    "hints": [
      "Sort by value/weight ratio",
      "Take as much as possible"
    ]
  },
  {
    "id": "160",
    "title": "Jump Game II",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum jumps to reach last index.",
    "examples": [
      {
        "input": "[2,3,1,1,4]",
        "output": "2"
      }
    ],
    "constraints": "1<=nums.length<=10^4",
    "hints": [
      "Track current and next reach",
      "Increment jumps when exceeding current reach"
    ]
  },
  {
    "id": "161",
    "title": "Gas Station",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Starting station to complete circular route, or -1.",
    "examples": [
      {
        "input": "gas=[1,2,3,4,5], cost=[3,4,5,1,2]",
        "output": "3"
      }
    ],
    "constraints": "1<=n<=10^5",
    "hints": [
      "Total gas>=cost means solution exists",
      "Reset start when tank negative"
    ]
  },
  {
    "id": "162",
    "title": "Task Scheduler",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum intervals to finish tasks with cooldown n.",
    "examples": [
      {
        "input": "tasks=['A','A','A','B','B','B'], n=2",
        "output": "8"
      }
    ],
    "constraints": "1<=n<=100",
    "hints": [
      "Sort by frequency",
      "Formula: (maxFreq-1)*(n+1)+count of maxFreq tasks"
    ]
  },
  {
    "id": "163",
    "title": "Assign Cookies",
    "topic": "Greedy",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Maximize content children assigning cookies.",
    "examples": [
      {
        "input": "g=[1,2,3], s=[1,1]",
        "output": "1"
      }
    ],
    "constraints": "1<=lengths<=3*10^4",
    "hints": [
      "Sort both arrays",
      "Assign smallest sufficient cookie"
    ]
  },
  {
    "id": "164",
    "title": "Non-overlapping Intervals",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Minimum intervals to remove to make rest non-overlapping.",
    "examples": [
      {
        "input": "[[1,2],[2,3],[3,4],[1,3]]",
        "output": "1"
      }
    ],
    "constraints": "1<=intervals.length<=10^5",
    "hints": [
      "Sort by end time",
      "Count max non-overlapping (activity selection)"
    ]
  },
  {
    "id": "165",
    "title": "Partition Labels",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Partition string so each letter in at most one part.",
    "examples": [
      {
        "input": "s='ababcbacadefegdehijhklij'",
        "output": "[9,7,8]"
      }
    ],
    "constraints": "1<=s.length<=500",
    "hints": [
      "Find last occurrence of each char",
      "Extend partition to max last occurrence"
    ]
  },
  {
    "id": "166",
    "title": "Minimum Platforms",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum train platforms needed.",
    "examples": [
      {
        "input": "arr=[900,940,950,1100], dep=[910,1200,1120,1130]",
        "output": "3"
      }
    ],
    "constraints": "1<=n<=10^4",
    "hints": [
      "Sort arrivals and departures",
      "Two pointer counting active trains"
    ]
  },
  {
    "id": "167",
    "title": "Candy Distribution",
    "topic": "Greedy",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum candies so higher-rated child gets more than neighbors.",
    "examples": [
      {
        "input": "ratings=[1,0,2]",
        "output": "5"
      }
    ],
    "constraints": "1<=ratings.length<=2*10^4",
    "hints": [
      "Two passes: left-to-right and right-to-left",
      "Take max of both"
    ]
  },
  {
    "id": "168",
    "title": "Lemonade Change",
    "topic": "Greedy",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro"
    ],
    "description": "Can you give correct change to all customers?",
    "examples": [
      {
        "input": "bills=[5,5,5,10,20]",
        "output": "true"
      }
    ],
    "constraints": "1<=bills.length<=10^5",
    "hints": [
      "Track $5 and $10 counts",
      "For $20 prefer $10+$5 over three $5s"
    ]
  },
  {
    "id": "169",
    "title": "Queue Reconstruction by Height",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Reconstruct queue from (height, k) pairs.",
    "examples": [
      {
        "input": "[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
        "output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]"
      }
    ],
    "constraints": "1<=people.length<=2000",
    "hints": [
      "Sort by height desc k asc",
      "Insert each at index k"
    ]
  },
  {
    "id": "170",
    "title": "Permutations",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return all permutations of distinct integers.",
    "examples": [
      {
        "input": "nums=[1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
      }
    ],
    "constraints": "1<=nums.length<=6",
    "hints": [
      "Swap current with each remaining",
      "Or use visited array"
    ]
  },
  {
    "id": "171",
    "title": "Combinations",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "All combinations of k numbers from range [1,n].",
    "examples": [
      {
        "input": "n=4, k=2",
        "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
      }
    ],
    "constraints": "1<=n<=20",
    "hints": [
      "Backtrack from start to n",
      "Prune if not enough numbers remaining"
    ]
  },
  {
    "id": "172",
    "title": "Combination Sum",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "All combinations summing to target. Reuse allowed.",
    "examples": [
      {
        "input": "candidates=[2,3,6,7], target=7",
        "output": "[[2,2,3],[7]]"
      }
    ],
    "constraints": "1<=candidates.length<=30",
    "hints": [
      "Backtrack with start index",
      "Sort and prune when sum > target"
    ]
  },
  {
    "id": "173",
    "title": "Combination Sum II",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "All unique combinations summing to target. No reuse.",
    "examples": [
      {
        "input": "[10,1,2,7,6,1,5], target=8",
        "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]"
      }
    ],
    "constraints": "1<=candidates.length<=100",
    "hints": [
      "Sort, backtrack with start index",
      "Skip duplicates at same level"
    ]
  },
  {
    "id": "174",
    "title": "Letter Combinations",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "All letter combinations for phone digits 2-9.",
    "examples": [
      {
        "input": "digits='23'",
        "output": "['ad','ae','af','bd','be','bf','cd','ce','cf']"
      }
    ],
    "constraints": "0<=digits.length<=4",
    "hints": [
      "Map digit to letters",
      "Backtrack adding one letter per digit"
    ]
  },
  {
    "id": "175",
    "title": "Subsets",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Return power set of unique elements.",
    "examples": [
      {
        "input": "nums=[1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
      }
    ],
    "constraints": "nums.length<=10",
    "hints": [
      "Backtrack include/exclude each element",
      "Or iterative"
    ]
  },
  {
    "id": "176",
    "title": "Subsets II",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Power set with duplicates, no duplicate subsets.",
    "examples": [
      {
        "input": "nums=[1,2,2]",
        "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]"
      }
    ],
    "constraints": "nums.length<=10",
    "hints": [
      "Sort first",
      "Skip duplicates at same recursion level"
    ]
  },
  {
    "id": "177",
    "title": "Word Search",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Check if word exists in character grid.",
    "examples": [
      {
        "input": "board grid, word='ABCCED'",
        "output": "true"
      }
    ],
    "constraints": "m,n>=1",
    "hints": [
      "DFS from cells matching first char",
      "Mark visited, backtrack after"
    ]
  },
  {
    "id": "178",
    "title": "N Queens",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Place N queens with no attacks. Return all solutions.",
    "examples": [
      {
        "input": "n=4",
        "output": "2 solutions"
      }
    ],
    "constraints": "1<=n<=9",
    "hints": [
      "Row by row placement",
      "Track columns, diagonals, anti-diagonals"
    ]
  },
  {
    "id": "179",
    "title": "Sudoku Solver",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Solve Sudoku by filling empty cells.",
    "examples": [
      {
        "input": "9x9 partial board",
        "output": "completed board"
      }
    ],
    "constraints": "board.length==9",
    "hints": [
      "Try digits 1-9 for each empty cell",
      "Backtrack on failure"
    ]
  },
  {
    "id": "180",
    "title": "Palindrome Partitioning",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "All ways to partition string into palindromes.",
    "examples": [
      {
        "input": "s='aab'",
        "output": "[['a','a','b'],['aa','b']]"
      }
    ],
    "constraints": "1<=s.length<=16",
    "hints": [
      "Backtrack trying palindrome prefixes",
      "Precompute palindromes with DP"
    ]
  },
  {
    "id": "181",
    "title": "Restore IP Addresses",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "All valid IP addresses from digit string.",
    "examples": [
      {
        "input": "s='25525511135'",
        "output": "['255.255.11.135','255.255.111.35']"
      }
    ],
    "constraints": "1<=s.length<=20",
    "hints": [
      "Place 3 dots in valid positions",
      "Each segment 0-255, no leading zeros"
    ]
  },
  {
    "id": "182",
    "title": "Remove Invalid Parentheses",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Remove minimum parentheses to make valid. All results.",
    "examples": [
      {
        "input": "s='()())()'",
        "output": "['()()()','(())()']"
      }
    ],
    "constraints": "1<=s.length<=25",
    "hints": [
      "BFS removing one at a time",
      "Stop at first level with valid strings"
    ]
  },
  {
    "id": "183",
    "title": "Expression Add Operators",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Insert +,-,* between digits to reach target.",
    "examples": [
      {
        "input": "num='123', target=6",
        "output": "['1*2*3','1+2+3']"
      }
    ],
    "constraints": "1<=num.length<=10",
    "hints": [
      "Backtrack inserting operators",
      "Track last multiplied term for *"
    ]
  },
  {
    "id": "184",
    "title": "Beautiful Arrangement",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Count permutations where perm[i]%i==0 or i%perm[i]==0.",
    "examples": [
      {
        "input": "n=2",
        "output": "2"
      }
    ],
    "constraints": "1<=n<=15",
    "hints": [
      "Backtrack assigning numbers to positions",
      "Prune when condition fails"
    ]
  },
  {
    "id": "185",
    "title": "Pow(x,n)",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Compute x raised to power n efficiently.",
    "examples": [
      {
        "input": "x=2.0, n=10",
        "output": "1024.0"
      },
      {
        "input": "x=2.0, n=-2",
        "output": "0.25"
      }
    ],
    "constraints": "-100<x<100",
    "hints": [
      "x^n = x^(n/2) * x^(n/2)",
      "Handle negative n with reciprocal"
    ]
  },
  {
    "id": "186",
    "title": "Count Inversions",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Count pairs where i<j but arr[i]>arr[j].",
    "examples": [
      {
        "input": "arr=[2,4,1,3,5]",
        "output": "3"
      }
    ],
    "constraints": "1<=arr.length<=10^5",
    "hints": [
      "Modify merge sort",
      "Count during merge step"
    ]
  },
  {
    "id": "187",
    "title": "Maximum Subarray DC",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Maximum subarray sum using divide and conquer.",
    "examples": [
      {
        "input": "[-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6"
      }
    ],
    "constraints": "-10^4<=nums[i]<=10^4",
    "hints": [
      "Split at midpoint",
      "Max is in left, right, or crosses mid"
    ]
  },
  {
    "id": "188",
    "title": "Different Ways to Add Parentheses",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "All possible results from different parenthesizations.",
    "examples": [
      {
        "input": "expression='2-1-1'",
        "output": "[0,2]"
      }
    ],
    "constraints": "1<=expression.length<=20",
    "hints": [
      "Divide at each operator",
      "Combine results from both sides"
    ]
  },
  {
    "id": "189",
    "title": "Kth Largest in Stream",
    "topic": "Divide and Conquer",
    "difficulty": "Easy",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Find kth largest in data stream.",
    "examples": [
      {
        "input": "KthLargest(3,[4,5,8,2]), add(3)=4",
        "output": "4"
      }
    ],
    "constraints": "1<=k<=10^4",
    "hints": [
      "Min-heap of size k",
      "Top is kth largest"
    ]
  },
  {
    "id": "190",
    "title": "Find K Closest Elements",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "K closest integers to x in sorted array.",
    "examples": [
      {
        "input": "arr=[1,2,3,4,5], k=4, x=3",
        "output": "[1,2,3,4]"
      }
    ],
    "constraints": "1<=k<=arr.length",
    "hints": [
      "Binary search for window start",
      "arr[mid]+arr[mid+k] >= 2*x"
    ]
  },
  {
    "id": "191",
    "title": "Closest Pair of Points",
    "topic": "Divide and Conquer",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Minimum Euclidean distance between any two points.",
    "examples": [
      {
        "input": "points=[(0,0),(3,4),(1,1)]",
        "output": "sqrt(2)"
      }
    ],
    "constraints": "2<=n<=10^5",
    "hints": [
      "Divide by x-midpoint",
      "Check strip of width 2*delta"
    ]
  },
  {
    "id": "192",
    "title": "Longest Substring K Repeating",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Longest substring where every char appears >= k times.",
    "examples": [
      {
        "input": "s='aaabb', k=3",
        "output": "3"
      }
    ],
    "constraints": "1<=s.length<=10^4",
    "hints": [
      "Divide at chars with freq < k",
      "Recurse on each segment"
    ]
  },
  {
    "id": "193",
    "title": "Construct Quad Tree",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "TCS",
      "Infosys",
      "Wipro",
      "Microsoft",
      "Google",
      "Amazon"
    ],
    "description": "Build quad tree from binary grid.",
    "examples": [
      {
        "input": "[[0,1],[1,0]]",
        "output": "5-node quad tree"
      }
    ],
    "constraints": "n is power of 2",
    "hints": [
      "Leaf if all same value",
      "Else divide into 4 quadrants"
    ]
  },
  {
    "id": "194",
    "title": "Beautiful Array",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Google",
      "Amazon",
      "Adobe",
      "Samsung",
      "Atlassian"
    ],
    "description": "Permutation where A[k]*2 != A[i]+A[j] for i<k<j.",
    "examples": [
      {
        "input": "n=4",
        "output": "[2,1,4,3]"
      }
    ],
    "constraints": "1<=n<=1000",
    "hints": [
      "Odd numbers in first half evens in second",
      "Recursive construction"
    ]
  },
  {
    "id": "195",
    "title": "Best Time to Buy and Sell Stock II",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Facebook"
    ],
    "description": "Given an array prices where prices[i] is the price of a stock on day i, find the maximum profit. You can complete as many transactions as you like (buy one and sell one share multiple times), but you must sell before you buy again.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7",
        "explanation": "Buy day2 sell day3 profit=4, buy day4 sell day5 profit=3. Total=7."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 3*10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "hints": [
      "Add all positive differences between consecutive days."
    ]
  },
  {
    "id": "196",
    "title": "Rotate Array",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Amazon"
    ],
    "description": "Given an integer array nums, rotate the array to the right by k steps.",
    "examples": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3]",
        "explanation": "Rotate right 3 times."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= k <= 10^5"
    ],
    "hints": [
      "Reverse entire array, then reverse first k, then reverse rest."
    ]
  },
  {
    "id": "197",
    "title": "Pascal's Triangle",
    "topic": "Array",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Apple"
    ],
    "description": "Given an integer numRows, return the first numRows of Pascal's triangle.",
    "examples": [
      {
        "input": "numRows = 5",
        "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
        "explanation": "Each element is sum of two elements above it."
      }
    ],
    "constraints": [
      "1 <= numRows <= 30"
    ],
    "hints": [
      "Each row starts and ends with 1. Middle elements are sum of two above."
    ]
  },
  {
    "id": "198",
    "title": "Increasing Triplet Subsequence",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Amazon",
      "Microsoft"
    ],
    "description": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k].",
    "examples": [
      {
        "input": "nums = [1,2,3,4,5]",
        "output": "true",
        "explanation": "Any triplet like (1,2,3) works."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5*10^5",
      "-2^31 <= nums[i] <= 2^31-1"
    ],
    "hints": [
      "Track first and second smallest values. If you find a value larger than second, return true."
    ]
  },
  {
    "id": "199",
    "title": "Find All Duplicates in Array",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given an integer array nums of length n where all integers are in range [1, n], return an array of all integers that appear twice.",
    "examples": [
      {
        "input": "nums = [4,3,2,7,8,2,3,1]",
        "output": "[2,3]",
        "explanation": "2 and 3 each appear twice."
      }
    ],
    "constraints": [
      "n == nums.length",
      "1 <= n <= 10^5",
      "1 <= nums[i] <= n"
    ],
    "hints": [
      "Use index as hash: negate value at index nums[i]-1. If already negative, it's a duplicate."
    ]
  },
  {
    "id": "200",
    "title": "Sliding Window Maximum",
    "topic": "Array",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft"
    ],
    "description": "Given an array nums and an integer k, return the max sliding window for each window of size k.",
    "examples": [
      {
        "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
        "output": "[3,3,5,5,6,7]",
        "explanation": "Max of each window of size 3."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= k <= nums.length"
    ],
    "hints": [
      "Use a monotonic deque. Maintain indices of useful elements."
    ]
  },
  {
    "id": "201",
    "title": "Minimum Size Subarray Sum",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Facebook"
    ],
    "description": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is >= target.",
    "examples": [
      {
        "input": "nums = [2,3,1,2,4,3], target = 7",
        "output": "2",
        "explanation": "Subarray [4,3] has minimum length."
      }
    ],
    "constraints": [
      "1 <= target <= 10^9",
      "1 <= nums.length <= 10^5"
    ],
    "hints": [
      "Sliding window. Expand right, shrink left while sum >= target."
    ]
  },
  {
    "id": "202",
    "title": "3Sum Closest",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Bloomberg"
    ],
    "description": "Given integer array nums and integer target, return the sum of three integers that is closest to target.",
    "examples": [
      {
        "input": "nums = [-1,2,1,-4], target = 1",
        "output": "2",
        "explanation": "Sum -1+2+1=2 is closest to 1."
      }
    ],
    "constraints": [
      "3 <= nums.length <= 500",
      "-1000 <= nums[i] <= 1000"
    ],
    "hints": [
      "Sort array. Two-pointer approach for each fixed element."
    ]
  },
  {
    "id": "203",
    "title": "Trap Water Container",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given n non-negative integers representing elevation map, compute how much water it can trap after raining. (Two-pointer variant)",
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "6 units of water trapped."
      }
    ],
    "constraints": [
      "n == height.length",
      "1 <= n <= 2*10^4"
    ],
    "hints": [
      "Use two pointers from both ends. Track leftMax and rightMax."
    ]
  },
  {
    "id": "204",
    "title": "Longest Mountain in Array",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Return the length of the longest mountain subarray. A mountain is defined as: at least 3 elements, strictly increasing then strictly decreasing.",
    "examples": [
      {
        "input": "arr = [2,1,4,7,3,2,5]",
        "output": "5",
        "explanation": "[1,4,7,3,2] is a mountain of length 5."
      }
    ],
    "constraints": [
      "1 <= arr.length <= 10^4",
      "0 <= arr[i] <= 10^4"
    ],
    "hints": [
      "For each peak (arr[i-1]<arr[i]>arr[i+1]), expand left and right."
    ]
  },
  {
    "id": "205",
    "title": "Count Subarrays with K Distinct",
    "topic": "Array",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given an integer array nums and an integer k, return the number of good subarrays with exactly k distinct integers.",
    "examples": [
      {
        "input": "nums = [1,2,1,2,3], k = 2",
        "output": "7",
        "explanation": "Subarrays with exactly 2 distinct: [1,2],[2,1],[1,2],[2,3],[1,2,1],[2,1,2],[1,2,1,2]."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 2*10^4",
      "1 <= nums[i] <= nums.length",
      "1 <= k <= nums.length"
    ],
    "hints": [
      "atMost(k) - atMost(k-1). Use sliding window with hashmap."
    ]
  },
  {
    "id": "206",
    "title": "Maximum Consecutive Ones III",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Facebook",
      "Google"
    ],
    "description": "Given a binary array nums and an integer k, return the maximum number of consecutive 1s if you can flip at most k 0s.",
    "examples": [
      {
        "input": "nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2",
        "output": "6",
        "explanation": "Flip two zeros."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "nums[i] is 0 or 1",
      "0 <= k <= nums.length"
    ],
    "hints": [
      "Sliding window. Track count of zeros in window. Shrink when zeros > k."
    ]
  },
  {
    "id": "207",
    "title": "Majority Element II",
    "topic": "Array",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given an integer array nums, return all elements that appear more than n/3 times.",
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "[3]",
        "explanation": "3 appears more than n/3 times."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5*10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "hints": [
      "Extended Boyer-Moore voting algorithm with two candidates."
    ]
  },
  {
    "id": "208",
    "title": "String to Integer (atoi)",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Microsoft",
      "Bloomberg"
    ],
    "description": "Implement the myAtoi function which converts a string to a 32-bit signed integer.",
    "examples": [
      {
        "input": "s = '42'",
        "output": "42",
        "explanation": "Parse leading whitespace, sign, then digits. Clamp to INT range."
      }
    ],
    "constraints": [
      "0 <= s.length <= 200"
    ],
    "hints": [
      "Handle whitespace, sign, digit parsing, and overflow carefully."
    ]
  },
  {
    "id": "209",
    "title": "Zigzag Conversion",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Bloomberg"
    ],
    "description": "Write the string 'PAYPALISHIRING' in a zigzag pattern on a given number of rows and return the string read line by line.",
    "examples": [
      {
        "input": "s = 'PAYPALISHIRING', numRows = 3",
        "output": "'PAHNAPLSIIGYIR'",
        "explanation": "Write in zigzag across 3 rows."
      }
    ],
    "constraints": [
      "1 <= s.length <= 1000",
      "1 <= numRows <= 1000"
    ],
    "hints": [
      "Use numRows lists, track current row and direction."
    ]
  },
  {
    "id": "210",
    "title": "Multiply Strings",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Amazon",
      "Google"
    ],
    "description": "Given two non-negative integers num1 and num2 represented as strings, return their product as a string. Do not use BigInteger or convert to integer directly.",
    "examples": [
      {
        "input": "num1 = '123', num2 = '456'",
        "output": "'56088'",
        "explanation": "Simulate grade-school multiplication."
      }
    ],
    "constraints": [
      "1 <= num1.length, num2.length <= 200",
      "num1 and num2 consist of digits only"
    ],
    "hints": [
      "Use a result array of size m+n. Multiply each digit pair and accumulate."
    ]
  },
  {
    "id": "211",
    "title": "Minimum Window Substring II",
    "topic": "String",
    "difficulty": "Hard",
    "companies": [
      "Facebook",
      "Amazon",
      "Google"
    ],
    "description": "Given strings s and t, return the minimum window in s which contains all characters of t. If no such window exists, return empty string.",
    "examples": [
      {
        "input": "s = 'ADOBECODEBANC', t = 'ABC'",
        "output": "'BANC'",
        "explanation": "BANC contains A, B, C."
      }
    ],
    "constraints": [
      "1 <= s.length, t.length <= 10^5"
    ],
    "hints": [
      "Sliding window with two pointers. Use frequency maps to track required chars."
    ]
  },
  {
    "id": "212",
    "title": "Largest Rectangle in Histogram",
    "topic": "String",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft"
    ],
    "description": "Given an array of integers heights representing a histogram, return the area of the largest rectangle in the histogram.",
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "Rectangle between bars 3 and 4 with height 5 gives area 10."
      }
    ],
    "constraints": [
      "1 <= heights.length <= 10^5",
      "0 <= heights[i] <= 10^4"
    ],
    "hints": [
      "Monotonic stack. For each bar find left and right boundary where it's the minimum."
    ]
  },
  {
    "id": "213",
    "title": "Basic Calculator II",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Facebook",
      "Google"
    ],
    "description": "Implement a basic calculator to evaluate a simple expression string containing +, -, *, /.",
    "examples": [
      {
        "input": "s = '3+2*2'",
        "output": "7",
        "explanation": "Respect operator precedence."
      }
    ],
    "constraints": [
      "1 <= s.length <= 3*10^5"
    ],
    "hints": [
      "Use a stack. Handle * and / immediately, push + and - operands to stack."
    ]
  },
  {
    "id": "214",
    "title": "Isomorphic Strings",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if characters in s can be replaced to get t with a consistent mapping.",
    "examples": [
      {
        "input": "s = 'egg', t = 'add'",
        "output": "true",
        "explanation": "e->a, g->d."
      }
    ],
    "constraints": [
      "1 <= s.length <= 5*10^4"
    ],
    "hints": [
      "Use two hashmaps: s->t and t->s mapping."
    ]
  },
  {
    "id": "215",
    "title": "Word Pattern",
    "topic": "String",
    "difficulty": "Easy",
    "companies": [
      "Dropbox",
      "Amazon"
    ],
    "description": "Given a pattern and a string s, find if s follows the same pattern. Full match means there's a bijection between letters in pattern and words in s.",
    "examples": [
      {
        "input": "pattern = 'abba', s = 'dog cat cat dog'",
        "output": "true",
        "explanation": "a->dog, b->cat."
      }
    ],
    "constraints": [
      "1 <= pattern.length <= 300"
    ],
    "hints": [
      "Use two maps. One from pattern char to word, another from word to pattern char."
    ]
  },
  {
    "id": "216",
    "title": "Sentence Similarity",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given two sentences and a list of similar word pairs, determine if two sentences are similar. Words are similar if directly in the list.",
    "examples": [
      {
        "input": "s1=['great','acting','skills'], s2=['fine','drama','talent'], pairs=[['great','fine'],['drama','acting'],['skills','talent']]",
        "output": "true",
        "explanation": "Each word pair matches directly."
      }
    ],
    "constraints": [
      "1 <= s1.length, s2.length <= 1000"
    ],
    "hints": [
      "Store pairs in a set. For each word pair check both orderings."
    ]
  },
  {
    "id": "217",
    "title": "Minimum Remove to Make Valid Parentheses",
    "topic": "String",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Amazon",
      "Google"
    ],
    "description": "Given a string s of '(', ')' and lowercase letters, remove the minimum number of parentheses to make the resulting string valid.",
    "examples": [
      {
        "input": "s = 'lee(t(c)o)de)'",
        "output": "'lee(t(c)o)de'",
        "explanation": "Remove one extra ')'."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5"
    ],
    "hints": [
      "Use a stack to track indices of unmatched parentheses. Mark them for removal."
    ]
  },
  {
    "id": "218",
    "title": "Binary Tree Zigzag Level Order",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Microsoft",
      "Bloomberg"
    ],
    "description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values (alternating left-to-right and right-to-left).",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]",
        "explanation": "Level 1 L-R, level 2 R-L, etc."
      }
    ],
    "constraints": [
      "Number of nodes in [0, 2000]",
      "-100 <= Node.val <= 100"
    ],
    "hints": [
      "BFS with a flag to reverse alternate levels."
    ]
  },
  {
    "id": "219",
    "title": "Path Sum II",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Facebook"
    ],
    "description": "Given the root of a binary tree and integer targetSum, return all root-to-leaf paths where the path sum equals targetSum.",
    "examples": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22",
        "output": "[[5,4,11,2],[5,8,4,5]]",
        "explanation": "Two paths sum to 22."
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 5000",
      "-1000 <= Node.val, targetSum <= 1000"
    ],
    "hints": [
      "DFS backtracking. Add to path, recurse, remove on backtrack."
    ]
  },
  {
    "id": "220",
    "title": "Sum Root to Leaf Numbers",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Facebook"
    ],
    "description": "Given a binary tree containing digits 0-9, each root-to-leaf path represents a number. Return the total sum of all root-to-leaf numbers.",
    "examples": [
      {
        "input": "root = [1,2,3]",
        "output": "25",
        "explanation": "Path 1->2=12, path 1->3=13. Sum=25."
      }
    ],
    "constraints": [
      "Number of nodes in [1, 1000]",
      "0 <= Node.val <= 9"
    ],
    "hints": [
      "DFS passing current number = prev*10 + node.val."
    ]
  },
  {
    "id": "221",
    "title": "Count Complete Tree Nodes",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given the root of a complete binary tree, return the number of nodes. Design an O(log^2 n) algorithm.",
    "examples": [
      {
        "input": "root = [1,2,3,4,5,6]",
        "output": "6",
        "explanation": "6 nodes total."
      }
    ],
    "constraints": [
      "Number of nodes in [0, 5*10^4]",
      "0 <= Node.val <= 5*10^4"
    ],
    "hints": [
      "Compare left and right heights. If equal, left subtree is perfect. Use binary search."
    ]
  },
  {
    "id": "222",
    "title": "Subtree of Another Tree",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "Facebook",
      "Amazon"
    ],
    "description": "Given the roots of two binary trees root and subRoot, return true if subRoot is a subtree of root.",
    "examples": [
      {
        "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
        "output": "true",
        "explanation": "Subtree rooted at node 4 matches subRoot."
      }
    ],
    "constraints": [
      "1 <= nodes in root <= 2000",
      "1 <= nodes in subRoot <= 1000"
    ],
    "hints": [
      "For each node, check if isSameTree. O(m*n) solution."
    ]
  },
  {
    "id": "223",
    "title": "Populating Next Right Pointers",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Amazon",
      "Facebook"
    ],
    "description": "Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Use O(1) extra space.",
    "examples": [
      {
        "input": "root = [1,2,3,4,5,6,7]",
        "output": "Connected level by level",
        "explanation": "Use already connected nodes to traverse."
      }
    ],
    "constraints": [
      "Number of nodes in [0, 2^12 - 1]"
    ],
    "hints": [
      "Use curr.left.next = curr.right and curr.right.next = curr.next.left."
    ]
  },
  {
    "id": "224",
    "title": "Binary Tree Cameras",
    "topic": "Tree",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Install cameras on tree nodes. Each camera monitors its parent, itself, and immediate children. Return minimum cameras to monitor all nodes.",
    "examples": [
      {
        "input": "root = [0,0,null,0,0]",
        "output": "1",
        "explanation": "One camera on center node covers all."
      }
    ],
    "constraints": [
      "Number of nodes in [1, 1000]"
    ],
    "hints": [
      "Greedy DFS bottom-up. States: 0=needs coverage, 1=has camera, 2=covered."
    ]
  },
  {
    "id": "225",
    "title": "Distribute Coins in Binary Tree",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "You have a binary tree with n nodes. Each node has some coins and there are n total coins. In one move, you can transfer one coin along an edge. Return minimum moves.",
    "examples": [
      {
        "input": "root = [3,0,0]",
        "output": "2",
        "explanation": "Root has 3 coins, move one to each child."
      }
    ],
    "constraints": [
      "Number of nodes in [1, 100]",
      "0 <= Node.val <= 100"
    ],
    "hints": [
      "Post-order DFS. Moves = sum of abs(excess) at each node."
    ]
  },
  {
    "id": "226",
    "title": "Delete Nodes and Return Forest",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Facebook"
    ],
    "description": "Given the root of a binary tree and a list of values to delete, return the roots of the trees in the remaining forest.",
    "examples": [
      {
        "input": "root = [1,2,3,4,5,6,7], to_delete = [3,5]",
        "output": "[[1,2,null,4],[6],[7]]",
        "explanation": "Delete 3 and 5, return resulting roots."
      }
    ],
    "constraints": [
      "Number of nodes in [1, 1000]",
      "to_delete.length <= 1000"
    ],
    "hints": [
      "Post-order DFS. If node deleted, add non-null children to result."
    ]
  },
  {
    "id": "227",
    "title": "Merge Binary Trees",
    "topic": "Tree",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Bloomberg"
    ],
    "description": "Merge two binary trees by summing overlapping nodes. Non-overlapping nodes are kept as-is.",
    "examples": [
      {
        "input": "root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]",
        "output": "[3,4,5,5,4,null,7]",
        "explanation": "Overlapping nodes are summed."
      }
    ],
    "constraints": [
      "Number of nodes in [0, 2000]"
    ],
    "hints": [
      "Recursively merge. If either is null, return the other."
    ]
  },
  {
    "id": "228",
    "title": "01 BFS Shortest Path",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "In a grid where cells have weight 0 or 1, find the shortest path from top-left to bottom-right using 0-1 BFS (deque).",
    "examples": [
      {
        "input": "grid = [[0,1],[1,0]]",
        "output": "1",
        "explanation": "Path with total weight 1."
      }
    ],
    "constraints": [
      "1 <= grid.length, grid[0].length <= 100"
    ],
    "hints": [
      "Use a deque. Push to front for 0-weight edges, back for 1-weight edges."
    ]
  },
  {
    "id": "229",
    "title": "Alien Dictionary II",
    "topic": "Graph",
    "difficulty": "Hard",
    "companies": [
      "Facebook",
      "Airbnb",
      "Google"
    ],
    "description": "Given a list of words sorted lexicographically by an alien language, derive the order of characters in that language.",
    "examples": [
      {
        "input": "words = ['wrt','wrf','er','ett','rftt']",
        "output": "'wertf'",
        "explanation": "Topological sort of character DAG."
      }
    ],
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100"
    ],
    "hints": [
      "Build graph of char precedences by comparing adjacent words. Topological sort."
    ]
  },
  {
    "id": "230",
    "title": "Cheapest Flights Within K Stops",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Airbnb"
    ],
    "description": "Find the cheapest price from src to dst with at most k stops.",
    "examples": [
      {
        "input": "n=3, flights=[[0,1,100],[1,2,100],[0,2,500]], src=0, dst=2, k=1",
        "output": "200",
        "explanation": "0->1->2 costs 200."
      }
    ],
    "constraints": [
      "1 <= n <= 100",
      "0 <= flights.length <= n*(n-1)/2"
    ],
    "hints": [
      "Bellman-Ford for k+1 iterations, or modified Dijkstra with state (node, stops)."
    ]
  },
  {
    "id": "231",
    "title": "Keys and Rooms",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "There are n rooms labeled 0 to n-1. You start in room 0. Each room may contain keys to other rooms. Return true if you can visit all rooms.",
    "examples": [
      {
        "input": "rooms = [[1],[2],[3],[]]",
        "output": "true",
        "explanation": "Visit room 0->1->2->3."
      }
    ],
    "constraints": [
      "2 <= n <= 1000",
      "0 <= rooms[i].length <= 1000"
    ],
    "hints": [
      "DFS/BFS from room 0. Track visited rooms."
    ]
  },
  {
    "id": "232",
    "title": "Minimum Height Trees",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "For a tree of n nodes labeled 0 to n-1, find all nodes that, when used as roots, minimize the height of the tree.",
    "examples": [
      {
        "input": "n=4, edges=[[1,0],[1,2],[1,3]]",
        "output": "[1]",
        "explanation": "Node 1 as root gives height 1."
      }
    ],
    "constraints": [
      "1 <= n <= 2*10^4"
    ],
    "hints": [
      "Topological peeling: repeatedly remove leaf nodes until 1 or 2 remain."
    ]
  },
  {
    "id": "233",
    "title": "All Paths From Source to Target",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Facebook",
      "Amazon"
    ],
    "description": "Given a DAG of n nodes (0-indexed), find all paths from node 0 to node n-1.",
    "examples": [
      {
        "input": "graph = [[1,2],[3],[3],[]]",
        "output": "[[0,1,3],[0,2,3]]",
        "explanation": "Two paths from 0 to 3."
      }
    ],
    "constraints": [
      "n == graph.length",
      "2 <= n <= 15"
    ],
    "hints": [
      "DFS backtracking. Collect path when reaching n-1."
    ]
  },
  {
    "id": "234",
    "title": "Find the Town Judge",
    "topic": "Graph",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "In a town, there may be a judge. The judge trusts nobody, everybody trusts the judge. Find the judge or return -1.",
    "examples": [
      {
        "input": "n=3, trust=[[1,3],[2,3]]",
        "output": "3",
        "explanation": "Person 3 is trusted by 1 and 2, trusts nobody."
      }
    ],
    "constraints": [
      "1 <= n <= 1000",
      "0 <= trust.length <= 10^4"
    ],
    "hints": [
      "Track in-degree and out-degree. Judge has in-degree n-1 and out-degree 0."
    ]
  },
  {
    "id": "235",
    "title": "Accounts Merge",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Amazon",
      "Google"
    ],
    "description": "Given a list of accounts where each element is [name, email1, email2, ...], merge accounts that share common emails.",
    "examples": [
      {
        "input": "accounts=[['John','a@a.com','b@b.com'],['John','b@b.com','c@c.com']]",
        "output": "[['John','a@a.com','b@b.com','c@c.com']]",
        "explanation": "Same John, merge via shared email."
      }
    ],
    "constraints": [
      "1 <= accounts.length <= 1000"
    ],
    "hints": [
      "Union-Find on emails. Group emails by root, then reconstruct accounts."
    ]
  },
  {
    "id": "236",
    "title": "Evaluate Division",
    "topic": "Graph",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Google",
      "Amazon"
    ],
    "description": "Given equations like a/b=2.0 and queries like a/c, compute each query. Return -1 if the answer doesn't exist.",
    "examples": [
      {
        "input": "equations=[['a','b'],['b','c']], values=[2.0,3.0], queries=[['a','c'],['b','a']]",
        "output": "[6.0,0.5]",
        "explanation": "a/c=a/b*b/c=6.0."
      }
    ],
    "constraints": [
      "1 <= equations.length <= 20"
    ],
    "hints": [
      "Build weighted graph. DFS/BFS to find path product for each query."
    ]
  },
  {
    "id": "237",
    "title": "Longest Cycle in Graph",
    "topic": "Graph",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Find the length of the longest cycle in a directed graph where each node has at most one outgoing edge. Return -1 if no cycle.",
    "examples": [
      {
        "input": "edges = [3,3,4,2,3]",
        "output": "3",
        "explanation": "Cycle 2->4->3->2 has length 3."
      }
    ],
    "constraints": [
      "n == edges.length",
      "1 <= n <= 10^5"
    ],
    "hints": [
      "DFS with timestamps. Cycle length = current_time - visited_time[node]."
    ]
  },
  {
    "id": "238",
    "title": "Odd Even Linked List",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Amazon",
      "Facebook"
    ],
    "description": "Given the head of a singly linked list, group all odd-indexed nodes together followed by even-indexed nodes.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[1,3,5,2,4]",
        "explanation": "Odds: 1,3,5. Evens: 2,4."
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 10^4",
      "-10^6 <= Node.val <= 10^6"
    ],
    "hints": [
      "Maintain two pointers for odd and even lists. Connect them at the end."
    ]
  },
  {
    "id": "239",
    "title": "Swap Nodes in Pairs",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Microsoft",
      "Google"
    ],
    "description": "Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list.",
    "examples": [
      {
        "input": "head = [1,2,3,4]",
        "output": "[2,1,4,3]",
        "explanation": "Pairs (1,2) and (3,4) are swapped."
      }
    ],
    "constraints": [
      "0 <= number of nodes <= 100",
      "0 <= Node.val <= 100"
    ],
    "hints": [
      "Use dummy node. For each pair, rewire pointers."
    ]
  },
  {
    "id": "240",
    "title": "Reverse Nodes in k-Group",
    "topic": "Linked List",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Microsoft",
      "Google"
    ],
    "description": "Given a linked list, reverse the nodes of the list k at a time and return the modified list.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[2,1,4,3,5]",
        "explanation": "Reverse every 2 nodes."
      }
    ],
    "constraints": [
      "1 <= k <= nodes in list <= 5000"
    ],
    "hints": [
      "Count k nodes. Reverse group. Connect to next reversed group recursively."
    ]
  },
  {
    "id": "241",
    "title": "Flatten Multilevel Doubly Linked List",
    "topic": "Linked List",
    "difficulty": "Medium",
    "companies": [
      "Microsoft",
      "Facebook",
      "Amazon"
    ],
    "description": "Flatten a multilevel doubly linked list where some nodes have a child pointer to another linked list.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]",
        "output": "[1,2,3,7,8,11,12,9,10,4,5,6]",
        "explanation": "DFS flatten."
      }
    ],
    "constraints": [
      "Number of nodes in [0, 1000]"
    ],
    "hints": [
      "When encountering a child, insert child list between current and next."
    ]
  },
  {
    "id": "242",
    "title": "Convert Binary Number in Linked List",
    "topic": "Linked List",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given the head of a linked list representing a binary number, return its decimal value.",
    "examples": [
      {
        "input": "head = [1,0,1]",
        "output": "5",
        "explanation": "Binary 101 = 5."
      }
    ],
    "constraints": [
      "1 <= number of nodes <= 30",
      "Node.val is 0 or 1"
    ],
    "hints": [
      "Traverse list, build number: result = result*2 + node.val."
    ]
  },
  {
    "id": "243",
    "title": "Maximum Profit in Job Scheduling",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon",
      "Facebook"
    ],
    "description": "Schedule jobs with start time, end time, and profit. Find maximum profit of non-overlapping jobs.",
    "examples": [
      {
        "input": "startTime=[1,2,3,3], endTime=[3,4,5,6], profit=[50,10,40,70]",
        "output": "120",
        "explanation": "Jobs 1 and 4 give profit 50+70=120."
      }
    ],
    "constraints": [
      "1 <= startTime.length == endTime.length == profit.length <= 5*10^4"
    ],
    "hints": [
      "Sort by end time. DP with binary search for last non-overlapping job."
    ]
  },
  {
    "id": "244",
    "title": "Longest Arithmetic Subsequence",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon",
      "Microsoft"
    ],
    "description": "Find the length of the longest arithmetic subsequence in the given array.",
    "examples": [
      {
        "input": "nums = [3,6,9,12]",
        "output": "4",
        "explanation": "Entire array is arithmetic with diff=3."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 1000",
      "0 <= nums[i] <= 500"
    ],
    "hints": [
      "dp[i][d] = longest arithmetic subseq ending at i with diff d. Use hashmap."
    ]
  },
  {
    "id": "245",
    "title": "Paint Fence",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Google"
    ],
    "description": "Given n fence posts and k colors, find the number of ways to paint the fence so that no more than 2 adjacent posts have the same color.",
    "examples": [
      {
        "input": "n=3, k=2",
        "output": "6",
        "explanation": "Count valid colorings."
      }
    ],
    "constraints": [
      "1 <= n <= 50",
      "1 <= k <= 10^5"
    ],
    "hints": [
      "same = prev ways with same color, diff = prev ways * (k-1). Total = same + diff."
    ]
  },
  {
    "id": "246",
    "title": "Decode Ways II",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Facebook",
      "Amazon"
    ],
    "description": "A message can be decoded with digits 1-26 to letters A-Z, with '*' as wildcard (1-9). Count all decodings modulo 10^9+7.",
    "examples": [
      {
        "input": "s = '*'",
        "output": "9",
        "explanation": "'*' can represent 1-9, giving 9 decodings."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5"
    ],
    "hints": [
      "Extend decode ways DP. Handle '*' by multiplying possibilities."
    ]
  },
  {
    "id": "247",
    "title": "Stone Game",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Alex and Lee play a game with piles of stones. Alex goes first, they alternate picking from either end. Return true if Alex wins (always does with optimal play).",
    "examples": [
      {
        "input": "piles = [5,3,4,5]",
        "output": "true",
        "explanation": "Alex always wins."
      }
    ],
    "constraints": [
      "2 <= piles.length <= 500",
      "piles.length is even"
    ],
    "hints": [
      "Mathematical: Alex always wins (return true). Or dp[i][j] = max score difference."
    ]
  },
  {
    "id": "248",
    "title": "Minimum Cost for Tickets",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Facebook"
    ],
    "description": "You travel on certain days of the year. Buy 1-day, 7-day, or 30-day passes. Find minimum cost to travel on all given days.",
    "examples": [
      {
        "input": "days=[1,4,6,7,8,20], costs=[2,7,15]",
        "output": "11",
        "explanation": "Buy 7-day on day 1 (cost 7) and 1-day on day 20 (cost 2+2=4... optimal=11)."
      }
    ],
    "constraints": [
      "1 <= days.length <= 365",
      "1 <= costs[i] <= 1000"
    ],
    "hints": [
      "DP over days 1-365. For travel days: min of 3 pass options."
    ]
  },
  {
    "id": "249",
    "title": "Russian Doll Envelopes",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon",
      "Microsoft"
    ],
    "description": "Given 2D envelopes [w,h], find the maximum number of envelopes you can put one inside another (both dimensions strictly larger).",
    "examples": [
      {
        "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
        "output": "3",
        "explanation": "[2,3] -> [5,4] -> [6,7]."
      }
    ],
    "constraints": [
      "1 <= envelopes.length <= 10^5"
    ],
    "hints": [
      "Sort by width asc, height desc. Then LIS on heights only."
    ]
  },
  {
    "id": "250",
    "title": "Count Different Palindromic Subsequences",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Google"
    ],
    "description": "Given a string s, return the number of distinct non-empty palindromic subsequences in s. Return modulo 10^9+7.",
    "examples": [
      {
        "input": "s = 'bccb'",
        "output": "6",
        "explanation": "'b','c','bb','cc','bcb','bccb'."
      }
    ],
    "constraints": [
      "1 <= s.length <= 1000",
      "s[i] is in {'a','b','c','d'}"
    ],
    "hints": [
      "dp[i][j] = distinct palindromic subseqs in s[i..j]. Handle cases by char match."
    ]
  },
  {
    "id": "251",
    "title": "Arithmetic Slices",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Return the number of arithmetic slices (subarrays of length >= 3 with equal differences).",
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "3",
        "explanation": "[1,2,3],[2,3,4],[1,2,3,4] are arithmetic."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5000",
      "-1000 <= nums[i] <= 1000"
    ],
    "hints": [
      "dp[i] = count of slices ending at i. If diff matches, dp[i] = dp[i-1] + 1."
    ]
  },
  {
    "id": "252",
    "title": "Profitable Schemes",
    "topic": "Dynamic Programming",
    "difficulty": "Hard",
    "companies": [
      "Google"
    ],
    "description": "Given group sizes and profits of crimes, count schemes using at most n members with profit >= minProfit.",
    "examples": [
      {
        "input": "n=5, minProfit=3, group=[2,2], profit=[2,3]",
        "output": "2",
        "explanation": "Scheme 2 alone or both schemes qualify."
      }
    ],
    "constraints": [
      "1 <= n <= 100",
      "0 <= minProfit <= 100"
    ],
    "hints": [
      "3D DP: dp[k][members][profit]. Knapsack variant with profit clamped at minProfit."
    ]
  },
  {
    "id": "253",
    "title": "Domino and Tromino Tiling",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given n, return the number of ways to tile a 2 x n board with 2x1 dominoes and L-shaped trominoes.",
    "examples": [
      {
        "input": "n = 3",
        "output": "5",
        "explanation": "5 distinct tilings."
      }
    ],
    "constraints": [
      "1 <= n <= 1000"
    ],
    "hints": [
      "dp[i] = dp[i-1]*2 + dp[i-3]. Or track states for partial tilings."
    ]
  },
  {
    "id": "254",
    "title": "Minimum Falling Path Sum",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given an n x n matrix, return the minimum sum of a falling path. A falling path starts at any element in the first row and chooses one element from each row (adjacent columns).",
    "examples": [
      {
        "input": "matrix = [[2,1,3],[6,5,4],[7,8,9]]",
        "output": "13",
        "explanation": "Path 1->5->7=13."
      }
    ],
    "constraints": [
      "n == matrix.length == matrix[0].length",
      "1 <= n <= 100"
    ],
    "hints": [
      "DP in-place. Each cell = val + min(above-left, above, above-right)."
    ]
  },
  {
    "id": "255",
    "title": "Interleaving String",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft"
    ],
    "description": "Given strings s1, s2, s3, determine if s3 is formed by interleaving s1 and s2.",
    "examples": [
      {
        "input": "s1='aab', s2='axy', s3='aaxaby'",
        "output": "true",
        "explanation": "s1[0]+s2[0]+s1[1]+s2[1]+s1[2]+s2[2]."
      }
    ],
    "constraints": [
      "0 <= s1.length, s2.length <= 100"
    ],
    "hints": [
      "2D DP. dp[i][j] = can form s3[:i+j] using s1[:i] and s2[:j]."
    ]
  },
  {
    "id": "256",
    "title": "Target Sum",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Amazon",
      "Google"
    ],
    "description": "Given array nums and integer target, find the number of ways to assign + and - to each number to make the sum equal to target.",
    "examples": [
      {
        "input": "nums = [1,1,1,1,1], target = 3",
        "output": "5",
        "explanation": "5 ways to assign signs."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 20",
      "0 <= nums[i] <= 1000"
    ],
    "hints": [
      "DP or subset sum: P - N = target, P + N = sum, so P = (sum+target)/2. Count subsets."
    ]
  },
  {
    "id": "257",
    "title": "Greatest Sum Divisible by Three",
    "topic": "Dynamic Programming",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given an array nums, find the maximum sum divisible by three.",
    "examples": [
      {
        "input": "nums = [3,6,5,1,8]",
        "output": "18",
        "explanation": "3+6+1+8=18."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 4*10^4",
      "1 <= nums[i] <= 10^4"
    ],
    "hints": [
      "DP with states 0,1,2 (remainder mod 3). Update states for each number."
    ]
  },
  {
    "id": "258",
    "title": "Word Search II",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft"
    ],
    "description": "Given an m x n board of characters and a list of strings words, return all words in the board. Words can be constructed from adjacent cells.",
    "examples": [
      {
        "input": "board=[['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']], words=['oath','pea','eat','rain']",
        "output": "['eat','oath']",
        "explanation": "DFS with Trie."
      }
    ],
    "constraints": [
      "1 <= board.length, board[0].length <= 12",
      "1 <= words.length <= 3*10^4"
    ],
    "hints": [
      "Build Trie from words. DFS from each cell, pruning with Trie."
    ]
  },
  {
    "id": "259",
    "title": "Letter Case Permutation",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Amazon"
    ],
    "description": "Given a string s, transform every letter individually to be lowercase or uppercase to create another string. Return all possible strings.",
    "examples": [
      {
        "input": "s = 'a1b2'",
        "output": "['a1b2','a1B2','A1b2','A1B2']",
        "explanation": "Toggle each letter."
      }
    ],
    "constraints": [
      "1 <= s.length <= 12"
    ],
    "hints": [
      "Backtrack: for each char, if letter branch into lower and upper cases."
    ]
  },
  {
    "id": "260",
    "title": "Path with Maximum Gold",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "In a gold mine grid, collect maximum gold. You can start/stop anywhere, move in 4 directions, can't visit same cell twice, and can't enter cell with 0.",
    "examples": [
      {
        "input": "grid = [[0,6,0],[5,8,7],[0,9,0]]",
        "output": "24",
        "explanation": "9->8->7."
      }
    ],
    "constraints": [
      "1 <= grid.length, grid[0].length <= 15",
      "0 <= grid[i][j] <= 100"
    ],
    "hints": [
      "DFS from each non-zero cell. Mark visited, backtrack by restoring."
    ]
  },
  {
    "id": "261",
    "title": "Split String Into Max Unique Substrings",
    "topic": "Backtracking",
    "difficulty": "Medium",
    "companies": [
      "Google"
    ],
    "description": "Given a string s, return the maximum number of unique substrings that the string can be split into.",
    "examples": [
      {
        "input": "s = 'ababccc'",
        "output": "5",
        "explanation": "'a','b','ab','c','cc'."
      }
    ],
    "constraints": [
      "1 <= s.length <= 16"
    ],
    "hints": [
      "Backtrack: try each prefix, add to set if not seen, recurse on suffix."
    ]
  },
  {
    "id": "262",
    "title": "Tiling a Rectangle with Fewest Squares",
    "topic": "Backtracking",
    "difficulty": "Hard",
    "companies": [
      "Google"
    ],
    "description": "Return the minimum number of squares that tile a rectangle of size n x m.",
    "examples": [
      {
        "input": "n = 2, m = 3",
        "output": "3",
        "explanation": "Three 1x1 squares needed? No, 3 squares: one 2x2 and two 1x1... actually optimal is 3."
      }
    ],
    "constraints": [
      "1 <= n, m <= 13"
    ],
    "hints": [
      "Backtracking with memoization. Try placing largest possible square at leftmost unfilled cell."
    ]
  },
  {
    "id": "263",
    "title": "Longest Consecutive Sequence II",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Facebook"
    ],
    "description": "Find the length of the longest consecutive elements sequence in O(n).",
    "examples": [
      {
        "input": "nums = [100,4,200,1,3,2]",
        "output": "4",
        "explanation": "[1,2,3,4]."
      }
    ],
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "hints": [
      "Use set. Only start counting from numbers with no predecessor."
    ]
  },
  {
    "id": "264",
    "title": "Subarray with Zero Sum",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Microsoft",
      "Google"
    ],
    "description": "Given an array of integers, find if there is a subarray with sum equal to zero.",
    "examples": [
      {
        "input": "arr = [4, 2, -3, 1, 6]",
        "output": "true",
        "explanation": "Subarray [2,-3,1] sums to 0."
      }
    ],
    "constraints": [
      "1 <= arr.length <= 10^5",
      "-10^5 <= arr[i] <= 10^5"
    ],
    "hints": [
      "Use prefix sums. If same prefix sum appears twice, subarray between them sums to 0."
    ]
  },
  {
    "id": "265",
    "title": "Count Pairs With Given Sum",
    "topic": "Hash",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "TCS",
      "Wipro"
    ],
    "description": "Given an array of integers and a number k, count pairs whose sum equals k.",
    "examples": [
      {
        "input": "arr = [1, 5, 7, -1], k = 6",
        "output": "2",
        "explanation": "Pairs: (1,5) and (7,-1)."
      }
    ],
    "constraints": [
      "1 <= arr.length <= 10^5"
    ],
    "hints": [
      "Use hashmap. For each element check if k-element is in map."
    ]
  },
  {
    "id": "266",
    "title": "Longest Subarray with Equal 0s and 1s",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft"
    ],
    "description": "Find the length of the longest subarray with equal number of 0s and 1s.",
    "examples": [
      {
        "input": "arr = [0,1,0,1,1,1,0]",
        "output": "6",
        "explanation": "Subarray [0,1,0,1,1,0] has 3 zeros and 3 ones? Wait arr[0..5]=[0,1,0,1,1,1] has 2 zeros 4 ones. Correct: arr[0..3] has 2,2."
      }
    ],
    "constraints": [
      "1 <= arr.length <= 10^5"
    ],
    "hints": [
      "Replace 0 with -1. Find longest subarray with sum=0 using prefix sum hashmap."
    ]
  },
  {
    "id": "267",
    "title": "Four Sum Count",
    "topic": "Hash",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given four integer arrays, count how many tuples (i,j,k,l) satisfy nums1[i]+nums2[j]+nums3[k]+nums4[l]==0.",
    "examples": [
      {
        "input": "nums1=[1,2], nums2=[-2,-1], nums3=[-1,2], nums4=[0,2]",
        "output": "2",
        "explanation": "Two tuples sum to 0."
      }
    ],
    "constraints": [
      "1 <= n <= 200"
    ],
    "hints": [
      "Store all a+b sums in hashmap. For c,d check if -(c+d) is in map."
    ]
  },
  {
    "id": "268",
    "title": "Wiggle Sort II",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]...",
    "examples": [
      {
        "input": "nums = [1,5,1,1,6,4]",
        "output": "[1,6,1,5,1,4]",
        "explanation": "Valid wiggle arrangement."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5*10^4"
    ],
    "hints": [
      "Find median. Place larger-than-median at odd indices, smaller at even indices (reverse order)."
    ]
  },
  {
    "id": "269",
    "title": "Find K-th Smallest Pair Distance",
    "topic": "Sorting",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given an integer array nums and integer k, return the kth smallest value among all pairwise absolute differences.",
    "examples": [
      {
        "input": "nums = [1,3,1], k = 1",
        "output": "0",
        "explanation": "Pairs: (1,3)=2, (1,1)=0, (3,1)=2. Smallest is 0."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^6"
    ],
    "hints": [
      "Binary search on answer. For each mid, count pairs with diff <= mid using two pointers."
    ]
  },
  {
    "id": "270",
    "title": "Maximum Gap",
    "topic": "Sorting",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. Return 0 if less than 2 elements. Must run in linear time.",
    "examples": [
      {
        "input": "nums = [3,6,9,1]",
        "output": "3",
        "explanation": "Sorted: [1,3,6,9]. Max gap = 3."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "0 <= nums[i] <= 10^9"
    ],
    "hints": [
      "Bucket sort / Radix sort for O(n). Max gap is between buckets."
    ]
  },
  {
    "id": "271",
    "title": "Pancake Sorting",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Given array arr, sort it using pancake flips (reversing a prefix). Return sequence of flip sizes.",
    "examples": [
      {
        "input": "arr = [3,2,4,1]",
        "output": "[4,2,4,3]",
        "explanation": "Sequence of flips that sorts the array."
      }
    ],
    "constraints": [
      "1 <= arr.length <= 100"
    ],
    "hints": [
      "Find max, flip to front, flip to position. Repeat for decreasing size."
    ]
  },
  {
    "id": "272",
    "title": "Minimum Number of Arrows to Burst Balloons",
    "topic": "Sorting",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Facebook"
    ],
    "description": "Balloons span [xstart, xend]. An arrow shot at x bursts all balloons where xstart<=x<=xend. Find minimum arrows.",
    "examples": [
      {
        "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
        "output": "2",
        "explanation": "Two arrows at x=6 and x=11."
      }
    ],
    "constraints": [
      "1 <= points.length <= 10^5"
    ],
    "hints": [
      "Sort by end. Greedily shoot at end of first balloon when overlap ends."
    ]
  },
  {
    "id": "273",
    "title": "Find Minimum in Rotated Sorted Array II",
    "topic": "Searching",
    "difficulty": "Hard",
    "companies": [
      "Microsoft",
      "Amazon",
      "LinkedIn"
    ],
    "description": "Suppose an array sorted in ascending order is rotated and may contain duplicates. Find the minimum.",
    "examples": [
      {
        "input": "nums = [2,2,2,0,1]",
        "output": "0",
        "explanation": "Binary search with duplicate handling."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5000",
      "-5000 <= nums[i] <= 5000"
    ],
    "hints": [
      "Modified binary search. When mid == right, shrink right by 1 to handle duplicates."
    ]
  },
  {
    "id": "274",
    "title": "Search in 2D Matrix II",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Microsoft",
      "Google"
    ],
    "description": "Write an efficient algorithm to search for a value in an m x n matrix where each row and column is sorted.",
    "examples": [
      {
        "input": "matrix=[[1,4,7],[2,5,8],[3,6,9]], target=5",
        "output": "true",
        "explanation": "Start from top-right, move left if too big, down if too small."
      }
    ],
    "constraints": [
      "1 <= m, n <= 300"
    ],
    "hints": [
      "Start at top-right corner. Move left if current > target, down if current < target."
    ]
  },
  {
    "id": "275",
    "title": "Count of Range Sum",
    "topic": "Searching",
    "difficulty": "Hard",
    "companies": [
      "Google"
    ],
    "description": "Given integer array nums and bounds [lower, upper], return the number of range sums that lie in [lower, upper].",
    "examples": [
      {
        "input": "nums = [-2,5,-1], lower = -2, upper = 2",
        "output": "3",
        "explanation": "Three range sums fall in [-2, 2]."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5"
    ],
    "hints": [
      "Merge sort on prefix sums. Count pairs where upper-lower bound is satisfied."
    ]
  },
  {
    "id": "276",
    "title": "Koko Eating Bananas",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "Facebook",
      "Google",
      "Amazon"
    ],
    "description": "Koko has piles of bananas and h hours. Find minimum eating speed k such that she finishes all bananas within h hours.",
    "examples": [
      {
        "input": "piles = [3,6,7,11], h = 8",
        "output": "4",
        "explanation": "Speed 4: hours needed = 1+2+2+3=8."
      }
    ],
    "constraints": [
      "1 <= piles.length <= 10^4",
      "piles.length <= h <= 10^9"
    ],
    "hints": [
      "Binary search on speed. Check if speed k finishes within h hours."
    ]
  },
  {
    "id": "277",
    "title": "Split Array Largest Sum II",
    "topic": "Searching",
    "difficulty": "Hard",
    "companies": [
      "Facebook",
      "Google",
      "Amazon"
    ],
    "description": "Split array into m subarrays to minimize the largest sum among all subarrays.",
    "examples": [
      {
        "input": "nums = [7,2,5,10,8], m = 2",
        "output": "18",
        "explanation": "Split into [7,2,5] and [10,8]. Max sum = 18."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 1000",
      "1 <= m <= min(50, nums.length)"
    ],
    "hints": [
      "Binary search on answer. Check if we can split with max sum <= mid."
    ]
  },
  {
    "id": "278",
    "title": "Find Duplicate in Array",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Microsoft",
      "Google"
    ],
    "description": "Given array of n+1 integers where each is in [1,n], find the duplicate number. Must not modify array and use only constant extra space.",
    "examples": [
      {
        "input": "nums = [1,3,4,2,2]",
        "output": "2",
        "explanation": "2 appears twice."
      }
    ],
    "constraints": [
      "1 <= n <= 10^5",
      "nums[i] is in [1,n]"
    ],
    "hints": [
      "Floyd's cycle detection. Treat array as linked list where nums[i] points to nums[nums[i]]."
    ]
  },
  {
    "id": "279",
    "title": "Magnetic Force Between Two Balls",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Place m balls in n positions to maximize the minimum magnetic force (distance) between any two balls.",
    "examples": [
      {
        "input": "position = [1,2,3,4,7], m = 3",
        "output": "3",
        "explanation": "Place at 1,4,7. Min distance=3."
      }
    ],
    "constraints": [
      "2 <= n <= 10^5",
      "2 <= m <= n"
    ],
    "hints": [
      "Binary search on minimum distance. Check if m balls can be placed with >= mid distance."
    ]
  },
  {
    "id": "280",
    "title": "H-Index II",
    "topic": "Searching",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Facebook"
    ],
    "description": "Given citations array sorted in ascending order, find the researcher's h-index using binary search.",
    "examples": [
      {
        "input": "citations = [0,1,3,5,6]",
        "output": "3",
        "explanation": "3 papers have at least 3 citations."
      }
    ],
    "constraints": [
      "1 <= citations.length <= 10^5"
    ],
    "hints": [
      "Binary search. Check if n-mid papers have >= mid citations."
    ]
  },
  {
    "id": "281",
    "title": "Minimum Number of Refueling Stops",
    "topic": "Greedy",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Car starts with startFuel. Stations at positions with fuel. Find minimum stops to reach target.",
    "examples": [
      {
        "input": "target=100, startFuel=10, stations=[[10,60],[20,30],[30,30],[60,40]]",
        "output": "2",
        "explanation": "Refuel at station 1 and 4."
      }
    ],
    "constraints": [
      "1 <= target, startFuel <= 10^9"
    ],
    "hints": [
      "Max-heap greedy. When out of fuel, take the largest available fuel stop."
    ]
  },
  {
    "id": "282",
    "title": "Two City Scheduling",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Bloomberg"
    ],
    "description": "2n people, each person has a cost to fly to city A or B. Send exactly n to each city with minimum cost.",
    "examples": [
      {
        "input": "costs = [[10,20],[30,200],[400,50],[30,20]]",
        "output": "110",
        "explanation": "Send persons 1,2 to A and 3,4 to B."
      }
    ],
    "constraints": [
      "2 <= n <= 100"
    ],
    "hints": [
      "Sort by cost difference (costA - costB). First n go to A, rest to B."
    ]
  },
  {
    "id": "283",
    "title": "Car Pooling",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon",
      "Lyft"
    ],
    "description": "Given trips and capacity, determine if a car can pick up and drop off all passengers.",
    "examples": [
      {
        "input": "trips=[[2,1,5],[3,3,7]], capacity=4",
        "output": "false",
        "explanation": "At point 3-5, 2+3=5 > 4."
      }
    ],
    "constraints": [
      "1 <= trips.length <= 1000",
      "1 <= capacity <= 10^5"
    ],
    "hints": [
      "Difference array at 1001 size. Add passengers at start, remove at end. Check max."
    ]
  },
  {
    "id": "284",
    "title": "Smallest Range Covering Elements from K Lists",
    "topic": "Greedy",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Find the smallest range [a,b] that includes at least one number from each of k sorted lists.",
    "examples": [
      {
        "input": "nums=[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
        "output": "[20,24]",
        "explanation": "20 from list 2, 24 from list 1, 22 from list 3."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 3500"
    ],
    "hints": [
      "Min-heap with one element from each list. Track max. Advance min element."
    ]
  },
  {
    "id": "285",
    "title": "Reorganize String",
    "topic": "Greedy",
    "difficulty": "Medium",
    "companies": [
      "Google",
      "Amazon",
      "Facebook"
    ],
    "description": "Given a string s, rearrange so that no two adjacent characters are the same. Return empty string if impossible.",
    "examples": [
      {
        "input": "s = 'aab'",
        "output": "'aba'",
        "explanation": "Place most frequent char at alternating positions."
      }
    ],
    "constraints": [
      "1 <= s.length <= 500"
    ],
    "hints": [
      "Count frequencies. Use max-heap, always place most frequent non-adjacent char."
    ]
  },
  {
    "id": "286",
    "title": "Merge K Sorted Lists",
    "topic": "Divide and Conquer",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft",
      "Facebook"
    ],
    "description": "Merge k sorted linked lists and return it as one sorted list.",
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "Merge all lists optimally."
      }
    ],
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4"
    ],
    "hints": [
      "Divide and conquer: merge pairs of lists. Or use min-heap of size k."
    ]
  },
  {
    "id": "287",
    "title": "Find Kth Largest in Array",
    "topic": "Divide and Conquer",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Facebook",
      "Google"
    ],
    "description": "Find the kth largest element in an unsorted array using QuickSelect.",
    "examples": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2",
        "output": "5",
        "explanation": "2nd largest is 5."
      }
    ],
    "constraints": [
      "1 <= k <= nums.length <= 10^5"
    ],
    "hints": [
      "QuickSelect: partition around pivot. Recurse on correct side only. Avg O(n)."
    ]
  },
  {
    "id": "288",
    "title": "Beautiful Pairs",
    "topic": "Divide and Conquer",
    "difficulty": "Hard",
    "companies": [
      "Google"
    ],
    "description": "Given n points, find the pair with minimum distance. Use divide and conquer.",
    "examples": [
      {
        "input": "points = [[0,0],[1,1],[3,4],[5,1]]",
        "output": "1.41",
        "explanation": "Points (0,0) and (1,1) are closest."
      }
    ],
    "constraints": [
      "2 <= n <= 10^4"
    ],
    "hints": [
      "Divide by x-median. Recurse both halves. Check strip of width 2*min_dist."
    ]
  },
  {
    "id": "289",
    "title": "Majority Element DC",
    "topic": "Divide and Conquer",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Find the element appearing more than n/2 times using divide and conquer.",
    "examples": [
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2",
        "explanation": "2 appears 4 times > n/2=3.5."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5*10^4"
    ],
    "hints": [
      "Divide array in half. Majority in full array must be majority in at least one half."
    ]
  },
  {
    "id": "290",
    "title": "Reverse Pairs",
    "topic": "Divide and Conquer",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Count reverse pairs (i < j) where nums[i] > 2*nums[j].",
    "examples": [
      {
        "input": "nums = [1,3,2,3,1]",
        "output": "2",
        "explanation": "(3,1) and (3,1)."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5*10^4",
      "-2^31 <= nums[i] <= 2^31-1"
    ],
    "hints": [
      "Modified merge sort. Count pairs during merge phase before merging."
    ]
  },
  {
    "id": "291",
    "title": "Min Stack",
    "topic": "Stack",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft",
      "Bloomberg"
    ],
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    "examples": [
      {
        "input": "MinStack, push(-2), push(0), push(-3), getMin(), pop(), top(), getMin()",
        "output": "[-3, 0, -2]",
        "explanation": "Maintain auxiliary min stack."
      }
    ],
    "constraints": [
      "At most 3*10^4 calls"
    ],
    "hints": [
      "Maintain a parallel min-stack. Push current min alongside each element."
    ]
  },
  {
    "id": "292",
    "title": "Evaluate Reverse Polish Notation",
    "topic": "Stack",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "LinkedIn"
    ],
    "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.",
    "examples": [
      {
        "input": "tokens = ['2','1','+','3','*']",
        "output": "9",
        "explanation": "((2+1)*3) = 9."
      }
    ],
    "constraints": [
      "1 <= tokens.length <= 10^4"
    ],
    "hints": [
      "Stack-based. Push numbers, pop two for operators, push result."
    ]
  },
  {
    "id": "293",
    "title": "Daily Temperatures",
    "topic": "Stack",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Facebook"
    ],
    "description": "Given daily temperatures, return array where answer[i] is the number of days until a warmer temperature.",
    "examples": [
      {
        "input": "temperatures = [73,74,75,71,69,72,76,73]",
        "output": "[1,1,4,2,1,1,0,0]",
        "explanation": "Monotonic stack of indices."
      }
    ],
    "constraints": [
      "1 <= temperatures.length <= 10^5"
    ],
    "hints": [
      "Monotonic decreasing stack of indices. Pop when warmer day found."
    ]
  },
  {
    "id": "294",
    "title": "Next Greater Element I",
    "topic": "Stack",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Find the next greater number for every element in nums1 from nums2. Use monotonic stack.",
    "examples": [
      {
        "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
        "output": "[-1,3,-1]",
        "explanation": "Next greater of 4 is -1, 1 is 3, 2 is -1."
      }
    ],
    "constraints": [
      "1 <= nums1.length <= nums2.length <= 1000"
    ],
    "hints": [
      "Build a map of next greater from nums2 using monotonic stack."
    ]
  },
  {
    "id": "295",
    "title": "Asteroid Collision",
    "topic": "Stack",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Facebook"
    ],
    "description": "Given asteroids moving right (+) or left (-), find the state after all collisions. Same direction never collide. Larger magnitude wins; equal both explode.",
    "examples": [
      {
        "input": "asteroids = [5,10,-5]",
        "output": "[5,10]",
        "explanation": "10 and -5 collide; 10 survives."
      }
    ],
    "constraints": [
      "2 <= asteroids.length <= 10^4"
    ],
    "hints": [
      "Stack of right-moving asteroids. When left-moving: pop smaller right-movers."
    ]
  },
  {
    "id": "296",
    "title": "Implement Queue using Stacks",
    "topic": "Stack",
    "difficulty": "Easy",
    "companies": [
      "Amazon",
      "Bloomberg",
      "Microsoft"
    ],
    "description": "Implement a FIFO queue using only two stacks.",
    "examples": [
      {
        "input": "push(1),push(2),peek(),pop(),empty()",
        "output": "[1,1,false]",
        "explanation": "Amortized O(1) operations."
      }
    ],
    "constraints": [
      "At most 100 operations"
    ],
    "hints": [
      "Two stacks: inbox and outbox. Move all to outbox when outbox empty on pop/peek."
    ]
  },
  {
    "id": "297",
    "title": "Score of Parentheses",
    "topic": "Stack",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google"
    ],
    "description": "Given balanced parentheses string s, compute the score. '()' = 1, 'AB' = A+B, '(A)' = 2*A.",
    "examples": [
      {
        "input": "s = '(()(()))'",
        "output": "6",
        "explanation": "Depth-based or stack-based calculation."
      }
    ],
    "constraints": [
      "2 <= s.length <= 50"
    ],
    "hints": [
      "Stack approach: push 0 for '(', on ')' pop and compute score."
    ]
  },
  {
    "id": "298",
    "title": "Maximum Width of Binary Tree",
    "topic": "Tree",
    "difficulty": "Medium",
    "companies": [
      "Amazon",
      "Google",
      "Facebook"
    ],
    "description": "Find the maximum width of a binary tree. Width of a level is the number of nodes between leftmost and rightmost non-null nodes (including nulls in between).",
    "examples": [
      {
        "input": "root = [1,3,2,5,3,null,9]",
        "output": "4",
        "explanation": "Level 3: nodes 5,3,null,9 has width 4."
      }
    ],
    "constraints": [
      "Number of nodes in [1, 3000]",
      "-100 <= Node.val <= 100"
    ],
    "hints": [
      "BFS with position indices. Width = rightmost - leftmost + 1 at each level."
    ]
  },
  {
    "id": "299",
    "title": "Number of Visible People in Queue",
    "topic": "Stack",
    "difficulty": "Hard",
    "companies": [
      "Google",
      "Amazon"
    ],
    "description": "Find how many people each person in a queue can see to their right. Person i can see person j if everyone between has height < min(heights[i], heights[j]).",
    "examples": [
      {
        "input": "heights = [10,6,8,5,11,9]",
        "output": "[3,1,2,1,1,0]",
        "explanation": "Monotonic stack to count visible people."
      }
    ],
    "constraints": [
      "1 <= heights.length <= 10^5"
    ],
    "hints": [
      "Monotonic decreasing stack. For each person, count how many are popped + 1 if next is taller."
    ]
  },
  {
    "id": "300",
    "title": "Longest Valid Parentheses",
    "topic": "Stack",
    "difficulty": "Hard",
    "companies": [
      "Amazon",
      "Google",
      "Microsoft"
    ],
    "description": "Given string containing only '(' and ')', find the length of the longest valid parentheses substring.",
    "examples": [
      {
        "input": "s = ')()())'",
        "output": "4",
        "explanation": "'()()' is the longest valid substring."
      }
    ],
    "constraints": [
      "0 <= s.length <= 3*10^4"
    ],
    "hints": [
      "Stack storing indices. Start with [-1]. Push index for '(', pop for ')'; if empty push index, else update max."
    ]
  }
]